{"ast":null,"code":"import _createClass from \"/home/shanur/Documents/personal/angular-5-formbuilder/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/home/shanur/Documents/personal/angular-5-formbuilder/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgZone, Output, Renderer2, ContentChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nvar DROP_EFFECTS =\n/** @type {?} */\n[\"move\", \"copy\", \"link\"];\n/** @type {?} */\n\nvar CUSTOM_MIME_TYPE = \"application/x-dnd\";\n/** @type {?} */\n\nvar JSON_MIME_TYPE = \"application/json\";\n/** @type {?} */\n\nvar MSIE_MIME_TYPE = \"Text\";\n/**\n * @param {?} mimeType\n * @return {?}\n */\n\nfunction mimeTypeIsCustom(mimeType) {\n  return mimeType.substr(0, CUSTOM_MIME_TYPE.length) === CUSTOM_MIME_TYPE;\n}\n/**\n * @param {?} event\n * @return {?}\n */\n\n\nfunction getWellKnownMimeType(event) {\n  if (event.dataTransfer) {\n    /** @type {?} */\n    var types = event.dataTransfer.types; // IE 9 workaround.\n\n    if (!types) {\n      return MSIE_MIME_TYPE;\n    }\n\n    for (var i = 0; i < types.length; i++) {\n      if (types[i] === MSIE_MIME_TYPE || types[i] === JSON_MIME_TYPE || mimeTypeIsCustom(types[i])) {\n        return types[i];\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * @param {?} event\n * @param {?} data\n * @param {?} effectAllowed\n * @return {?}\n */\n\n\nfunction setDragData(event, data, effectAllowed) {\n  // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n  // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n\n  /** @type {?} */\n  var mimeType = CUSTOM_MIME_TYPE + (data.type ? \"-\" + data.type : \"\");\n  /** @type {?} */\n\n  var dataString = JSON.stringify(data);\n\n  try {\n    event.dataTransfer.setData(mimeType, dataString);\n  } catch (e) {\n    //   Setting a custom MIME type did not work, we are probably in IE or Edge.\n    try {\n      event.dataTransfer.setData(JSON_MIME_TYPE, dataString);\n    } catch (e) {\n      //   We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n      //   does not allow changing the cursor in the dragover event, therefore we have to choose\n      //   the one we want to display now by setting effectAllowed.\n\n      /** @type {?} */\n      var effectsAllowed = filterEffects(DROP_EFFECTS, effectAllowed);\n      event.dataTransfer.effectAllowed = effectsAllowed[0];\n      event.dataTransfer.setData(MSIE_MIME_TYPE, dataString);\n    }\n  }\n}\n/**\n * @param {?} event\n * @param {?} dragIsExternal\n * @return {?}\n */\n\n\nfunction getDropData(event, dragIsExternal) {\n  // check if the mime type is well known\n\n  /** @type {?} */\n  var mimeType = getWellKnownMimeType(event); // drag did not originate from [dndDraggable]\n\n  if (dragIsExternal === true) {\n    if (mimeType !== null && mimeTypeIsCustom(mimeType)) {\n      // the type of content is well known and safe to handle\n      return JSON.parse(event.dataTransfer.getData(mimeType));\n    } // the contained data is unknown, let user handle it\n\n\n    return {};\n  } // the type of content is well known and safe to handle\n\n\n  return JSON.parse(event.dataTransfer.getData(mimeType));\n}\n/**\n * @param {?} effects\n * @param {?} allowed\n * @return {?}\n */\n\n\nfunction filterEffects(effects, allowed) {\n  if (allowed === \"all\" || allowed === \"uninitialized\") {\n    return effects;\n  }\n\n  return effects.filter(\n  /**\n  * @param {?} effect\n  * @return {?}\n  */\n  function (effect) {\n    return allowed.toLowerCase().indexOf(effect) !== -1;\n  });\n}\n/**\n * @param {?} parentElement\n * @param {?} childElement\n * @return {?}\n */\n\n\nfunction getDirectChildElement(parentElement, childElement) {\n  /** @type {?} */\n  var directChild = childElement;\n\n  while (directChild.parentNode !== parentElement) {\n    // reached root node without finding given parent\n    if (!directChild.parentNode) {\n      return null;\n    }\n\n    directChild = directChild.parentNode;\n  }\n\n  return (\n    /** @type {?} */\n    directChild\n  );\n}\n/**\n * @param {?} event\n * @param {?} element\n * @param {?} horizontal\n * @return {?}\n */\n\n\nfunction shouldPositionPlaceholderBeforeElement(event, element, horizontal) {\n  /** @type {?} */\n  var bounds = element.getBoundingClientRect(); // If the pointer is in the upper half of the list item element,\n  // we position the placeholder before the list item, otherwise after it.\n\n  if (horizontal) {\n    return event.clientX < bounds.left + bounds.width / 2;\n  }\n\n  return event.clientY < bounds.top + bounds.height / 2;\n}\n/**\n * @param {?} event\n * @param {?} dragImage\n * @return {?}\n */\n\n\nfunction calculateDragImageOffset(event, dragImage) {\n  /** @type {?} */\n  var dragImageComputedStyle = window.getComputedStyle(dragImage);\n  /** @type {?} */\n\n  var paddingTop = parseFloat(dragImageComputedStyle.paddingTop) || 0;\n  /** @type {?} */\n\n  var paddingLeft = parseFloat(dragImageComputedStyle.paddingLeft) || 0;\n  /** @type {?} */\n\n  var borderTop = parseFloat(dragImageComputedStyle.borderTopWidth) || 0;\n  /** @type {?} */\n\n  var borderLeft = parseFloat(dragImageComputedStyle.borderLeftWidth) || 0;\n  return {\n    x: event.offsetX + paddingLeft + borderLeft,\n    y: event.offsetY + paddingTop + borderTop\n  };\n}\n/**\n * @param {?} event\n * @param {?} dragImage\n * @param {?} offsetFunction\n * @return {?}\n */\n\n\nfunction setDragImage(event, dragImage, offsetFunction) {\n  /** @type {?} */\n  var offset = offsetFunction(event, dragImage) || {\n    x: 0,\n    y: 0\n  };\n\n  /** @type {?} */\n  event.dataTransfer.setDragImage(dragImage, offset.x, offset.y);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar _dndState = {\n  isDragging: false,\n  dropEffect: \"none\",\n  effectAllowed: \"all\",\n  type: undefined\n};\n/**\n * @param {?} event\n * @param {?} effectAllowed\n * @param {?} type\n * @return {?}\n */\n\nfunction startDrag(event, effectAllowed, type) {\n  _dndState.isDragging = true;\n  _dndState.dropEffect = \"none\";\n  _dndState.effectAllowed = effectAllowed;\n  _dndState.type = type;\n  event.dataTransfer.effectAllowed = effectAllowed;\n}\n/**\n * @return {?}\n */\n\n\nfunction endDrag() {\n  _dndState.isDragging = false;\n  _dndState.dropEffect = undefined;\n  _dndState.effectAllowed = undefined;\n  _dndState.type = undefined;\n}\n/**\n * @param {?} event\n * @param {?} dropEffect\n * @return {?}\n */\n\n\nfunction setDropEffect(event, dropEffect) {\n  if (_dndState.isDragging === true) {\n    _dndState.dropEffect = dropEffect;\n  }\n\n  event.dataTransfer.dropEffect = dropEffect;\n}\n/**\n * @param {?} event\n * @param {?=} effectAllowed\n * @return {?}\n */\n\n\nfunction getDropEffect(event, effectAllowed) {\n  /** @type {?} */\n  var dataTransferEffectAllowed = event.dataTransfer ?\n  /** @type {?} */\n  event.dataTransfer.effectAllowed : \"uninitialized\";\n  /** @type {?} */\n\n  var effects = filterEffects(DROP_EFFECTS, dataTransferEffectAllowed);\n\n  if (_dndState.isDragging === true) {\n    effects = filterEffects(effects, _dndState.effectAllowed);\n  }\n\n  if (effectAllowed) {\n    effects = filterEffects(effects, effectAllowed);\n  } // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n  // therefore the following modifier keys will only affect other operating systems.\n\n\n  if (effects.length === 0) {\n    return \"none\";\n  }\n\n  if (event.ctrlKey && effects.indexOf(\"copy\") !== -1) {\n    return \"copy\";\n  }\n\n  if (event.altKey && effects.indexOf(\"link\") !== -1) {\n    return \"link\";\n  }\n\n  return (\n    /** @type {?} */\n    effects[0]\n  );\n}\n/**\n * @param {?} event\n * @return {?}\n */\n\n\nfunction getDndType(event) {\n  if (_dndState.isDragging === true) {\n    return _dndState.type;\n  }\n  /** @type {?} */\n\n\n  var mimeType = getWellKnownMimeType(event);\n\n  if (mimeType === null) {\n    return undefined;\n  }\n\n  if (mimeType === MSIE_MIME_TYPE || mimeType === JSON_MIME_TYPE) {\n    return undefined;\n  }\n\n  return mimeType.substr(CUSTOM_MIME_TYPE.length + 1) || undefined;\n}\n/**\n * @return {?}\n */\n\n\nfunction isExternalDrag() {\n  return _dndState.isDragging === false;\n}\n/** @type {?} */\n\n\nvar dndState =\n/** @type {?} */\n_dndState;\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nvar DndDragImageRefDirective =\n/**\n * @param {?} parent\n * @param {?} elementRef\n */\nfunction DndDragImageRefDirective(parent, elementRef) {\n  _classCallCheck(this, DndDragImageRefDirective);\n\n  parent.registerDragImage(elementRef);\n};\n\nDndDragImageRefDirective.ɵfac = function DndDragImageRefDirective_Factory(t) {\n  return new (t || DndDragImageRefDirective)(ɵngcc0.ɵɵdirectiveInject(DndDraggableDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n};\n\nDndDragImageRefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DndDragImageRefDirective,\n  selectors: [[\"\", \"dndDragImageRef\", \"\"]]\n});\n/** @nocollapse */\n\nDndDragImageRefDirective.ctorParameters = function () {\n  return [{\n    type: DndDraggableDirective\n  }, {\n    type: ElementRef\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DndDragImageRefDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[dndDragImageRef]\"\n    }]\n  }], function () {\n    return [{\n      type: DndDraggableDirective\n    }, {\n      type: ɵngcc0.ElementRef\n    }];\n  }, null);\n})();\n\nvar DndDraggableDirective = /*#__PURE__*/function () {\n  /**\n   * @param {?} elementRef\n   * @param {?} renderer\n   * @param {?} ngZone\n   */\n  function DndDraggableDirective(elementRef, renderer, ngZone) {\n    var _this = this;\n\n    _classCallCheck(this, DndDraggableDirective);\n\n    this.elementRef = elementRef;\n    this.renderer = renderer;\n    this.ngZone = ngZone;\n    this.dndEffectAllowed = \"copy\";\n    this.dndDraggingClass = \"dndDragging\";\n    this.dndDraggingSourceClass = \"dndDraggingSource\";\n    this.dndDraggableDisabledClass = \"dndDraggableDisabled\";\n    this.dndDragImageOffsetFunction = calculateDragImageOffset;\n    this.dndStart = new EventEmitter();\n    this.dndDrag = new EventEmitter();\n    this.dndEnd = new EventEmitter();\n    this.dndMoved = new EventEmitter();\n    this.dndCopied = new EventEmitter();\n    this.dndLinked = new EventEmitter();\n    this.dndCanceled = new EventEmitter();\n    this.draggable = true;\n    this.isDragStarted = false;\n\n    this.dragEventHandler =\n    /**\n    * @param {?} event\n    * @return {?}\n    */\n    function (event) {\n      return _this.onDrag(event);\n    };\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  _createClass(DndDraggableDirective, [{\n    key: \"ngAfterViewInit\",\n\n    /**\n     * @return {?}\n     */\n    value: function ngAfterViewInit() {\n      var _this2 = this;\n\n      this.ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      function () {\n        _this2.elementRef.nativeElement.addEventListener(\"drag\", _this2.dragEventHandler);\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.elementRef.nativeElement.removeEventListener(\"drag\", this.dragEventHandler);\n\n      if (this.isDragStarted === true) {\n        endDrag();\n      }\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onDragStart\",\n    value: function onDragStart(event) {\n      var _this3 = this;\n\n      if (this.draggable === false) {\n        return false;\n      } // check if there is dnd handle and if the dnd handle was used to start the drag\n\n\n      if (typeof this.dndHandle !== \"undefined\" && typeof event._dndUsingHandle === \"undefined\") {\n        return false;\n      } // initialize global state\n\n\n      startDrag(event, this.dndEffectAllowed, this.dndType);\n      this.isDragStarted = true;\n      setDragData(event, {\n        data: this.dndDraggable,\n        type: this.dndType\n      }, dndState.effectAllowed);\n      this.dragImage = this.determineDragImage(); // set dragging css class prior to setDragImage so styles are applied before\n      // TODO breaking change: add class to elementRef rather than drag image which could be another element\n\n      this.renderer.addClass(this.dragImage, this.dndDraggingClass); // set custom dragimage if present\n      // set dragimage if drag is started from dndHandle\n\n      if (typeof this.dndDragImageElementRef !== \"undefined\" || typeof event._dndUsingHandle !== \"undefined\") {\n        setDragImage(event, this.dragImage, this.dndDragImageOffsetFunction);\n      } // add dragging source css class on first drag event\n\n      /** @type {?} */\n\n\n      var unregister = this.renderer.listen(this.elementRef.nativeElement, \"drag\",\n      /**\n      * @return {?}\n      */\n      function () {\n        _this3.renderer.addClass(_this3.elementRef.nativeElement, _this3.dndDraggingSourceClass);\n\n        unregister();\n      });\n      this.dndStart.emit(event);\n      event.stopPropagation();\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onDrag\",\n    value: function onDrag(event) {\n      this.dndDrag.emit(event);\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onDragEnd\",\n    value: function onDragEnd(event) {\n      var _this4 = this;\n\n      // get drop effect from custom stored state as its not reliable across browsers\n\n      /** @type {?} */\n      var dropEffect = dndState.dropEffect;\n      /** @type {?} */\n\n      var dropEffectEmitter;\n\n      switch (dropEffect) {\n        case \"copy\":\n          dropEffectEmitter = this.dndCopied;\n          break;\n\n        case \"link\":\n          dropEffectEmitter = this.dndLinked;\n          break;\n\n        case \"move\":\n          dropEffectEmitter = this.dndMoved;\n          break;\n\n        default:\n          dropEffectEmitter = this.dndCanceled;\n          break;\n      }\n\n      dropEffectEmitter.emit(event);\n      this.dndEnd.emit(event); // reset global state\n\n      endDrag();\n      this.isDragStarted = false;\n      this.renderer.removeClass(this.dragImage, this.dndDraggingClass); // IE9 special hammering\n\n      window.setTimeout(\n      /**\n      * @return {?}\n      */\n      function () {\n        _this4.renderer.removeClass(_this4.elementRef.nativeElement, _this4.dndDraggingSourceClass);\n      }, 0);\n      event.stopPropagation();\n    }\n    /**\n     * @param {?} handle\n     * @return {?}\n     */\n\n  }, {\n    key: \"registerDragHandle\",\n    value: function registerDragHandle(handle) {\n      this.dndHandle = handle;\n    }\n    /**\n     * @param {?} elementRef\n     * @return {?}\n     */\n\n  }, {\n    key: \"registerDragImage\",\n    value: function registerDragImage(elementRef) {\n      this.dndDragImageElementRef = elementRef;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"determineDragImage\",\n    value: function determineDragImage() {\n      // evaluate custom drag image existence\n      if (typeof this.dndDragImageElementRef !== \"undefined\") {\n        return (\n          /** @type {?} */\n          this.dndDragImageElementRef.nativeElement\n        );\n      } else {\n        return this.elementRef.nativeElement;\n      }\n    }\n  }, {\n    key: \"dndDisableIf\",\n    set: function set(value) {\n      this.draggable = !value;\n\n      if (this.draggable) {\n        this.renderer.removeClass(this.elementRef.nativeElement, this.dndDraggableDisabledClass);\n      } else {\n        this.renderer.addClass(this.elementRef.nativeElement, this.dndDraggableDisabledClass);\n      }\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"dndDisableDragIf\",\n    set: function set(value) {\n      this.dndDisableIf = value;\n    }\n  }]);\n\n  return DndDraggableDirective;\n}();\n\nDndDraggableDirective.ɵfac = function DndDraggableDirective_Factory(t) {\n  return new (t || DndDraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nDndDraggableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DndDraggableDirective,\n  selectors: [[\"\", \"dndDraggable\", \"\"]],\n  hostVars: 1,\n  hostBindings: function DndDraggableDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"dragstart\", function DndDraggableDirective_dragstart_HostBindingHandler($event) {\n        return ctx.onDragStart($event);\n      })(\"dragend\", function DndDraggableDirective_dragend_HostBindingHandler($event) {\n        return ctx.onDragEnd($event);\n      });\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"draggable\", ctx.draggable);\n    }\n  },\n  inputs: {\n    dndEffectAllowed: \"dndEffectAllowed\",\n    dndDraggingClass: \"dndDraggingClass\",\n    dndDraggingSourceClass: \"dndDraggingSourceClass\",\n    dndDraggableDisabledClass: \"dndDraggableDisabledClass\",\n    dndDragImageOffsetFunction: \"dndDragImageOffsetFunction\",\n    dndDisableIf: \"dndDisableIf\",\n    dndDisableDragIf: \"dndDisableDragIf\",\n    dndDraggable: \"dndDraggable\",\n    dndType: \"dndType\"\n  },\n  outputs: {\n    dndStart: \"dndStart\",\n    dndDrag: \"dndDrag\",\n    dndEnd: \"dndEnd\",\n    dndMoved: \"dndMoved\",\n    dndCopied: \"dndCopied\",\n    dndLinked: \"dndLinked\",\n    dndCanceled: \"dndCanceled\"\n  }\n});\n/** @nocollapse */\n\nDndDraggableDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }, {\n    type: NgZone\n  }];\n};\n\nDndDraggableDirective.propDecorators = {\n  dndDraggable: [{\n    type: Input\n  }],\n  dndEffectAllowed: [{\n    type: Input\n  }],\n  dndType: [{\n    type: Input\n  }],\n  dndDraggingClass: [{\n    type: Input\n  }],\n  dndDraggingSourceClass: [{\n    type: Input\n  }],\n  dndDraggableDisabledClass: [{\n    type: Input\n  }],\n  dndDragImageOffsetFunction: [{\n    type: Input\n  }],\n  dndStart: [{\n    type: Output\n  }],\n  dndDrag: [{\n    type: Output\n  }],\n  dndEnd: [{\n    type: Output\n  }],\n  dndMoved: [{\n    type: Output\n  }],\n  dndCopied: [{\n    type: Output\n  }],\n  dndLinked: [{\n    type: Output\n  }],\n  dndCanceled: [{\n    type: Output\n  }],\n  draggable: [{\n    type: HostBinding,\n    args: [\"attr.draggable\"]\n  }],\n  dndDisableIf: [{\n    type: Input\n  }],\n  dndDisableDragIf: [{\n    type: Input\n  }],\n  onDragStart: [{\n    type: HostListener,\n    args: [\"dragstart\", [\"$event\"]]\n  }],\n  onDragEnd: [{\n    type: HostListener,\n    args: [\"dragend\", [\"$event\"]]\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DndDraggableDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[dndDraggable]\"\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    dndEffectAllowed: [{\n      type: Input\n    }],\n    dndDraggingClass: [{\n      type: Input\n    }],\n    dndDraggingSourceClass: [{\n      type: Input\n    }],\n    dndDraggableDisabledClass: [{\n      type: Input\n    }],\n    dndDragImageOffsetFunction: [{\n      type: Input\n    }],\n    dndStart: [{\n      type: Output\n    }],\n    dndDrag: [{\n      type: Output\n    }],\n    dndEnd: [{\n      type: Output\n    }],\n    dndMoved: [{\n      type: Output\n    }],\n    dndCopied: [{\n      type: Output\n    }],\n    dndLinked: [{\n      type: Output\n    }],\n    dndCanceled: [{\n      type: Output\n    }],\n    draggable: [{\n      type: HostBinding,\n      args: [\"attr.draggable\"]\n    }],\n    dndDisableIf: [{\n      type: Input\n    }],\n    dndDisableDragIf: [{\n      type: Input\n    }],\n\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onDragStart: [{\n      type: HostListener,\n      args: [\"dragstart\", [\"$event\"]]\n    }],\n\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onDragEnd: [{\n      type: HostListener,\n      args: [\"dragend\", [\"$event\"]]\n    }],\n    dndDraggable: [{\n      type: Input\n    }],\n    dndType: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar DndPlaceholderRefDirective =\n/**\n * @param {?} elementRef\n */\nfunction DndPlaceholderRefDirective(elementRef) {\n  _classCallCheck(this, DndPlaceholderRefDirective);\n\n  this.elementRef = elementRef;\n};\n\nDndPlaceholderRefDirective.ɵfac = function DndPlaceholderRefDirective_Factory(t) {\n  return new (t || DndPlaceholderRefDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n};\n\nDndPlaceholderRefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DndPlaceholderRefDirective,\n  selectors: [[\"\", \"dndPlaceholderRef\", \"\"]]\n});\n/** @nocollapse */\n\nDndPlaceholderRefDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DndPlaceholderRefDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[dndPlaceholderRef]\"\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }];\n  }, null);\n})();\n\nvar DndDropzoneDirective = /*#__PURE__*/function () {\n  /**\n   * @param {?} ngZone\n   * @param {?} elementRef\n   * @param {?} renderer\n   */\n  function DndDropzoneDirective(ngZone, elementRef, renderer) {\n    var _this5 = this;\n\n    _classCallCheck(this, DndDropzoneDirective);\n\n    this.ngZone = ngZone;\n    this.elementRef = elementRef;\n    this.renderer = renderer;\n    this.dndAllowExternal = false;\n    this.dndHorizontal = false;\n    this.dndDragoverClass = \"dndDragover\";\n    this.dndDropzoneDisabledClass = \"dndDropzoneDisabled\";\n    this.dndDragover = new EventEmitter();\n    this.dndDrop = new EventEmitter();\n    this.placeholder = null;\n    this.disabled = false;\n\n    this.dragEnterEventHandler =\n    /**\n    * @param {?} event\n    * @return {?}\n    */\n    function (event) {\n      return _this5.onDragEnter(event);\n    };\n\n    this.dragOverEventHandler =\n    /**\n    * @param {?} event\n    * @return {?}\n    */\n    function (event) {\n      return _this5.onDragOver(event);\n    };\n\n    this.dragLeaveEventHandler =\n    /**\n    * @param {?} event\n    * @return {?}\n    */\n    function (event) {\n      return _this5.onDragLeave(event);\n    };\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  _createClass(DndDropzoneDirective, [{\n    key: \"ngAfterViewInit\",\n\n    /**\n     * @return {?}\n     */\n    value: function ngAfterViewInit() {\n      var _this6 = this;\n\n      this.placeholder = this.tryGetPlaceholder();\n      this.removePlaceholderFromDOM();\n      this.ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      function () {\n        _this6.elementRef.nativeElement.addEventListener(\"dragenter\", _this6.dragEnterEventHandler);\n\n        _this6.elementRef.nativeElement.addEventListener(\"dragover\", _this6.dragOverEventHandler);\n\n        _this6.elementRef.nativeElement.addEventListener(\"dragleave\", _this6.dragLeaveEventHandler);\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.elementRef.nativeElement.removeEventListener(\"dragenter\", this.dragEnterEventHandler);\n      this.elementRef.nativeElement.removeEventListener(\"dragover\", this.dragOverEventHandler);\n      this.elementRef.nativeElement.removeEventListener(\"dragleave\", this.dragLeaveEventHandler);\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onDragEnter\",\n    value: function onDragEnter(event) {\n      // check if another dropzone is activated\n      if (event._dndDropzoneActive === true) {\n        this.cleanupDragoverState();\n        return;\n      } // set as active if the target element is inside this dropzone\n\n\n      if (typeof event._dndDropzoneActive === \"undefined\") {\n        /** @type {?} */\n        var newTarget = document.elementFromPoint(event.clientX, event.clientY);\n\n        if (this.elementRef.nativeElement.contains(newTarget)) {\n          event._dndDropzoneActive = true;\n        }\n      } // check if this drag event is allowed to drop on this dropzone\n\n      /** @type {?} */\n\n\n      var type = getDndType(event);\n\n      if (this.isDropAllowed(type) === false) {\n        return;\n      } // allow the dragenter\n\n\n      event.preventDefault();\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onDragOver\",\n    value: function onDragOver(event) {\n      // With nested dropzones, we want to ignore this event if a child dropzone\n      // has already handled a dragover.  Historically, event.stopPropagation() was\n      // used to prevent this bubbling, but that prevents any dragovers outside the\n      // ngx-drag-drop component, and stops other use cases such as scrolling on drag.\n      // Instead, we can check if the event was already prevented by a child and bail early.\n      if (event.defaultPrevented) {\n        return;\n      } // check if this drag event is allowed to drop on this dropzone\n\n      /** @type {?} */\n\n\n      var type = getDndType(event);\n\n      if (this.isDropAllowed(type) === false) {\n        return;\n      }\n\n      this.checkAndUpdatePlaceholderPosition(event);\n      /** @type {?} */\n\n      var dropEffect = getDropEffect(event, this.dndEffectAllowed);\n\n      if (dropEffect === \"none\") {\n        this.cleanupDragoverState();\n        return;\n      } // allow the dragover\n\n\n      event.preventDefault(); // set the drop effect\n\n      setDropEffect(event, dropEffect);\n      this.dndDragover.emit(event);\n      this.renderer.addClass(this.elementRef.nativeElement, this.dndDragoverClass);\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onDrop\",\n    value: function onDrop(event) {\n      try {\n        // check if this drag event is allowed to drop on this dropzone\n\n        /** @type {?} */\n        var type = getDndType(event);\n\n        if (this.isDropAllowed(type) === false) {\n          return;\n        }\n        /** @type {?} */\n\n\n        var data = getDropData(event, isExternalDrag());\n\n        if (this.isDropAllowed(data.type) === false) {\n          return;\n        } // signal custom drop handling\n\n\n        event.preventDefault();\n        /** @type {?} */\n\n        var dropEffect = getDropEffect(event);\n        setDropEffect(event, dropEffect);\n\n        if (dropEffect === \"none\") {\n          return;\n        }\n        /** @type {?} */\n\n\n        var dropIndex = this.getPlaceholderIndex(); // if for whatever reason the placeholder is not present in the DOM but it should be there\n        // we don't allow/emit the drop event since it breaks the contract\n        // seems to only happen if drag and drop is executed faster than the DOM updates\n\n        if (dropIndex === -1) {\n          return;\n        }\n\n        this.dndDrop.emit({\n          event: event,\n          dropEffect: dropEffect,\n          isExternal: isExternalDrag(),\n          data: data.data,\n          index: dropIndex,\n          type: type\n        });\n        event.stopPropagation();\n      } finally {\n        this.cleanupDragoverState();\n      }\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onDragLeave\",\n    value: function onDragLeave(event) {\n      // check if still inside this dropzone and not yet handled by another dropzone\n      if (typeof event._dndDropzoneActive === \"undefined\") {\n        /** @type {?} */\n        var newTarget = document.elementFromPoint(event.clientX, event.clientY);\n\n        if (this.elementRef.nativeElement.contains(newTarget)) {\n          event._dndDropzoneActive = true;\n          return;\n        }\n      }\n\n      this.cleanupDragoverState(); // cleanup drop effect when leaving dropzone\n\n      setDropEffect(event, \"none\");\n    }\n    /**\n     * @private\n     * @param {?=} type\n     * @return {?}\n     */\n\n  }, {\n    key: \"isDropAllowed\",\n    value: function isDropAllowed(type) {\n      // dropzone is disabled -> deny it\n      if (this.disabled === true) {\n        return false;\n      } // if drag did not start from our directive\n      // and external drag sources are not allowed -> deny it\n\n\n      if (isExternalDrag() === true && this.dndAllowExternal === false) {\n        return false;\n      } // no filtering by types -> allow it\n\n\n      if (!this.dndDropzone) {\n        return true;\n      } // no type set -> allow it\n\n\n      if (!type) {\n        return true;\n      }\n\n      if (Array.isArray(this.dndDropzone) === false) {\n        throw new Error(\"dndDropzone: bound value to [dndDropzone] must be an array!\");\n      } // if dropzone contains type -> allow it\n\n\n      return this.dndDropzone.indexOf(type) !== -1;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"tryGetPlaceholder\",\n    value: function tryGetPlaceholder() {\n      if (typeof this.dndPlaceholderRef !== \"undefined\") {\n        return (\n          /** @type {?} */\n          this.dndPlaceholderRef.elementRef.nativeElement\n        );\n      } // TODO nasty workaround needed because if ng-container / template is used @ContentChild() or DI will fail because\n      // of wrong context see angular bug https://github.com/angular/angular/issues/13517\n\n\n      return this.elementRef.nativeElement.querySelector(\"[dndPlaceholderRef]\");\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"removePlaceholderFromDOM\",\n    value: function removePlaceholderFromDOM() {\n      if (this.placeholder !== null && this.placeholder.parentNode !== null) {\n        this.placeholder.parentNode.removeChild(this.placeholder);\n      }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"checkAndUpdatePlaceholderPosition\",\n    value: function checkAndUpdatePlaceholderPosition(event) {\n      if (this.placeholder === null) {\n        return;\n      } // make sure the placeholder is in the DOM\n\n\n      if (this.placeholder.parentNode !== this.elementRef.nativeElement) {\n        this.renderer.appendChild(this.elementRef.nativeElement, this.placeholder);\n      } // update the position if the event originates from a child element of the dropzone\n\n      /** @type {?} */\n\n\n      var directChild = getDirectChildElement(this.elementRef.nativeElement,\n      /** @type {?} */\n      event.target); // early exit if no direct child or direct child is placeholder\n\n      if (directChild === null || directChild === this.placeholder) {\n        return;\n      }\n      /** @type {?} */\n\n\n      var positionPlaceholderBeforeDirectChild = shouldPositionPlaceholderBeforeElement(event, directChild, this.dndHorizontal);\n\n      if (positionPlaceholderBeforeDirectChild) {\n        // do insert before only if necessary\n        if (directChild.previousSibling !== this.placeholder) {\n          this.renderer.insertBefore(this.elementRef.nativeElement, this.placeholder, directChild);\n        }\n      } else {\n        // do insert after only if necessary\n        if (directChild.nextSibling !== this.placeholder) {\n          this.renderer.insertBefore(this.elementRef.nativeElement, this.placeholder, directChild.nextSibling);\n        }\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"getPlaceholderIndex\",\n    value: function getPlaceholderIndex() {\n      if (this.placeholder === null) {\n        return undefined;\n      }\n      /** @type {?} */\n\n\n      var element =\n      /** @type {?} */\n      this.elementRef.nativeElement;\n      return Array.prototype.indexOf.call(element.children, this.placeholder);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"cleanupDragoverState\",\n    value: function cleanupDragoverState() {\n      this.renderer.removeClass(this.elementRef.nativeElement, this.dndDragoverClass);\n      this.removePlaceholderFromDOM();\n    }\n  }, {\n    key: \"dndDisableIf\",\n    set: function set(value) {\n      this.disabled = !!value;\n\n      if (this.disabled) {\n        this.renderer.addClass(this.elementRef.nativeElement, this.dndDropzoneDisabledClass);\n      } else {\n        this.renderer.removeClass(this.elementRef.nativeElement, this.dndDropzoneDisabledClass);\n      }\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"dndDisableDropIf\",\n    set: function set(value) {\n      this.dndDisableIf = value;\n    }\n  }]);\n\n  return DndDropzoneDirective;\n}();\n\nDndDropzoneDirective.ɵfac = function DndDropzoneDirective_Factory(t) {\n  return new (t || DndDropzoneDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n};\n\nDndDropzoneDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DndDropzoneDirective,\n  selectors: [[\"\", \"dndDropzone\", \"\"]],\n  contentQueries: function DndDropzoneDirective_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, DndPlaceholderRefDirective, true);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dndPlaceholderRef = _t.first);\n    }\n  },\n  hostBindings: function DndDropzoneDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"drop\", function DndDropzoneDirective_drop_HostBindingHandler($event) {\n        return ctx.onDrop($event);\n      });\n    }\n  },\n  inputs: {\n    dndAllowExternal: \"dndAllowExternal\",\n    dndHorizontal: \"dndHorizontal\",\n    dndDragoverClass: \"dndDragoverClass\",\n    dndDropzoneDisabledClass: \"dndDropzoneDisabledClass\",\n    dndDisableIf: \"dndDisableIf\",\n    dndDisableDropIf: \"dndDisableDropIf\",\n    dndDropzone: \"dndDropzone\",\n    dndEffectAllowed: \"dndEffectAllowed\"\n  },\n  outputs: {\n    dndDragover: \"dndDragover\",\n    dndDrop: \"dndDrop\"\n  }\n});\n/** @nocollapse */\n\nDndDropzoneDirective.ctorParameters = function () {\n  return [{\n    type: NgZone\n  }, {\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }];\n};\n\nDndDropzoneDirective.propDecorators = {\n  dndDropzone: [{\n    type: Input\n  }],\n  dndEffectAllowed: [{\n    type: Input\n  }],\n  dndAllowExternal: [{\n    type: Input\n  }],\n  dndHorizontal: [{\n    type: Input\n  }],\n  dndDragoverClass: [{\n    type: Input\n  }],\n  dndDropzoneDisabledClass: [{\n    type: Input\n  }],\n  dndDragover: [{\n    type: Output\n  }],\n  dndDrop: [{\n    type: Output\n  }],\n  dndPlaceholderRef: [{\n    type: ContentChild,\n    args: [DndPlaceholderRefDirective]\n  }],\n  dndDisableIf: [{\n    type: Input\n  }],\n  dndDisableDropIf: [{\n    type: Input\n  }],\n  onDrop: [{\n    type: HostListener,\n    args: [\"drop\", [\"$event\"]]\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DndDropzoneDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[dndDropzone]\"\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }];\n  }, {\n    dndAllowExternal: [{\n      type: Input\n    }],\n    dndHorizontal: [{\n      type: Input\n    }],\n    dndDragoverClass: [{\n      type: Input\n    }],\n    dndDropzoneDisabledClass: [{\n      type: Input\n    }],\n    dndDragover: [{\n      type: Output\n    }],\n    dndDrop: [{\n      type: Output\n    }],\n    dndDisableIf: [{\n      type: Input\n    }],\n    dndDisableDropIf: [{\n      type: Input\n    }],\n\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onDrop: [{\n      type: HostListener,\n      args: [\"drop\", [\"$event\"]]\n    }],\n    dndDropzone: [{\n      type: Input\n    }],\n    dndEffectAllowed: [{\n      type: Input\n    }],\n    dndPlaceholderRef: [{\n      type: ContentChild,\n      args: [DndPlaceholderRefDirective]\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar DndHandleDirective = /*#__PURE__*/function () {\n  /**\n   * @param {?} parent\n   */\n  function DndHandleDirective(parent) {\n    _classCallCheck(this, DndHandleDirective);\n\n    this.draggable = true;\n    parent.registerDragHandle(this);\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  _createClass(DndHandleDirective, [{\n    key: \"onDragEvent\",\n    value: function onDragEvent(event) {\n      event._dndUsingHandle = true;\n    }\n  }]);\n\n  return DndHandleDirective;\n}();\n\nDndHandleDirective.ɵfac = function DndHandleDirective_Factory(t) {\n  return new (t || DndHandleDirective)(ɵngcc0.ɵɵdirectiveInject(DndDraggableDirective));\n};\n\nDndHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DndHandleDirective,\n  selectors: [[\"\", \"dndHandle\", \"\"]],\n  hostVars: 1,\n  hostBindings: function DndHandleDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"dragstart\", function DndHandleDirective_dragstart_HostBindingHandler($event) {\n        return ctx.onDragEvent($event);\n      })(\"dragend\", function DndHandleDirective_dragend_HostBindingHandler($event) {\n        return ctx.onDragEvent($event);\n      });\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"draggable\", ctx.draggable);\n    }\n  }\n});\n/** @nocollapse */\n\nDndHandleDirective.ctorParameters = function () {\n  return [{\n    type: DndDraggableDirective\n  }];\n};\n\nDndHandleDirective.propDecorators = {\n  draggable: [{\n    type: HostBinding,\n    args: [\"attr.draggable\"]\n  }],\n  onDragEvent: [{\n    type: HostListener,\n    args: [\"dragstart\", [\"$event\"]]\n  }, {\n    type: HostListener,\n    args: [\"dragend\", [\"$event\"]]\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DndHandleDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[dndHandle]\"\n    }]\n  }], function () {\n    return [{\n      type: DndDraggableDirective\n    }];\n  }, {\n    draggable: [{\n      type: HostBinding,\n      args: [\"attr.draggable\"]\n    }],\n\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onDragEvent: [{\n      type: HostListener,\n      args: [\"dragstart\", [\"$event\"]]\n    }, {\n      type: HostListener,\n      args: [\"dragend\", [\"$event\"]]\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar DndModule = function DndModule() {\n  _classCallCheck(this, DndModule);\n};\n\nDndModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: DndModule\n});\nDndModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function DndModule_Factory(t) {\n    return new (t || DndModule)();\n  },\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DndModule, {\n    declarations: function declarations() {\n      return [DndDraggableDirective, DndDropzoneDirective, DndHandleDirective, DndPlaceholderRefDirective, DndDragImageRefDirective];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [DndDraggableDirective, DndDropzoneDirective, DndHandleDirective, DndPlaceholderRefDirective, DndDragImageRefDirective];\n    }\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DndModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [DndDraggableDirective, DndDropzoneDirective, DndHandleDirective, DndPlaceholderRefDirective, DndDragImageRefDirective],\n      exports: [DndDraggableDirective, DndDropzoneDirective, DndHandleDirective, DndPlaceholderRefDirective, DndDragImageRefDirective]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DndDragImageRefDirective, DndDraggableDirective, DndPlaceholderRefDirective, DndDropzoneDirective, DndHandleDirective, DndModule };","map":{"version":3,"sources":["ngx-drag-drop/dnd-utils.ts","ngx-drag-drop/dnd-state.ts","ngx-drag-drop/dnd-draggable.directive.ts","ngx-drag-drop/dnd-dropzone.directive.ts","ngx-drag-drop/dnd-handle.directive.ts","ngx-drag-drop/dnd.module.ts"],"names":[],"mappings":"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","sourcesContent":["import { DropEffect, EffectAllowed } from \"./dnd-types\";\n\nexport interface DragDropData {\n  data?:any;\n  type?:string;\n}\n\nexport interface DndEvent extends DragEvent {\n  _dndUsingHandle?:boolean;\n  _dndDropzoneActive?:true;\n}\n\nexport type DndDragImageOffsetFunction = ( event:DragEvent, dragImage:Element ) => { x:number, y:number };\n\nexport const DROP_EFFECTS = [ \"move\", \"copy\", \"link\" ] as DropEffect[];\n\nexport const CUSTOM_MIME_TYPE = \"application/x-dnd\";\nexport const JSON_MIME_TYPE = \"application/json\";\nexport const MSIE_MIME_TYPE = \"Text\";\n\nfunction mimeTypeIsCustom( mimeType:string ) {\n\n  return mimeType.substr( 0, CUSTOM_MIME_TYPE.length ) === CUSTOM_MIME_TYPE;\n}\n\nexport function getWellKnownMimeType( event:DragEvent ):string | null {\n\n  if( event.dataTransfer ) {\n\n    const types = event.dataTransfer.types;\n\n    // IE 9 workaround.\n    if( !types ) {\n\n      return MSIE_MIME_TYPE;\n    }\n\n    for( let i = 0; i < types.length; i++ ) {\n\n      if( types[ i ] === MSIE_MIME_TYPE\n        || types[ i ] === JSON_MIME_TYPE\n        || mimeTypeIsCustom( types[ i ] ) ) {\n\n        return types[ i ];\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function setDragData( event:DragEvent, data:DragDropData, effectAllowed:EffectAllowed ):void {\n\n  // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n  // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n  const mimeType = CUSTOM_MIME_TYPE + (data.type ? (\"-\" + data.type) : \"\");\n\n  const dataString = JSON.stringify( data );\n\n  try {\n\n    event.dataTransfer.setData( mimeType, dataString );\n\n  }\n  catch( e ) {\n\n    //   Setting a custom MIME type did not work, we are probably in IE or Edge.\n    try {\n\n      event.dataTransfer.setData( JSON_MIME_TYPE, dataString );\n\n    }\n    catch( e ) {\n\n      //   We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n      //   does not allow changing the cursor in the dragover event, therefore we have to choose\n      //   the one we want to display now by setting effectAllowed.\n      const effectsAllowed = filterEffects( DROP_EFFECTS, effectAllowed );\n      event.dataTransfer.effectAllowed = effectsAllowed[ 0 ];\n\n      event.dataTransfer.setData( MSIE_MIME_TYPE, dataString );\n    }\n  }\n}\n\nexport function getDropData( event:DragEvent, dragIsExternal:boolean ):DragDropData {\n\n  // check if the mime type is well known\n  const mimeType = getWellKnownMimeType( event );\n\n  // drag did not originate from [dndDraggable]\n  if( dragIsExternal === true ) {\n\n    if( mimeType !== null\n      && mimeTypeIsCustom( mimeType ) ) {\n\n      // the type of content is well known and safe to handle\n      return JSON.parse( event.dataTransfer.getData( mimeType ) );\n    }\n\n    // the contained data is unknown, let user handle it\n    return {};\n  }\n\n  // the type of content is well known and safe to handle\n  return JSON.parse( event.dataTransfer.getData( mimeType ) );\n}\n\nexport function filterEffects( effects:DropEffect[], allowed:EffectAllowed | DropEffect ):DropEffect[] {\n\n  if( allowed === \"all\"\n    || allowed === \"uninitialized\" ) {\n\n    return effects;\n  }\n\n  return effects.filter( function( effect ) {\n\n    return allowed.toLowerCase().indexOf( effect ) !== -1;\n  } );\n}\n\nexport function getDirectChildElement( parentElement:Element, childElement:Element ):Element | null {\n\n  let directChild:Node = childElement;\n\n  while( directChild.parentNode !== parentElement ) {\n\n    // reached root node without finding given parent\n    if( !directChild.parentNode ) {\n\n      return null;\n    }\n\n    directChild = directChild.parentNode;\n  }\n\n  return directChild as Element;\n}\n\nexport function shouldPositionPlaceholderBeforeElement( event:DragEvent, element:Element, horizontal:boolean ) {\n\n  const bounds = element.getBoundingClientRect();\n\n  // If the pointer is in the upper half of the list item element,\n  // we position the placeholder before the list item, otherwise after it.\n  if( horizontal ) {\n\n    return (event.clientX < bounds.left + bounds.width / 2);\n  }\n\n  return (event.clientY < bounds.top + bounds.height / 2);\n}\n\nexport function calculateDragImageOffset( event:DragEvent, dragImage:Element ):{ x:number, y:number } {\n\n  const dragImageComputedStyle = window.getComputedStyle( dragImage );\n  const paddingTop = parseFloat( dragImageComputedStyle.paddingTop ) || 0;\n  const paddingLeft = parseFloat( dragImageComputedStyle.paddingLeft ) || 0;\n  const borderTop = parseFloat( dragImageComputedStyle.borderTopWidth ) || 0;\n  const borderLeft = parseFloat( dragImageComputedStyle.borderLeftWidth ) || 0;\n\n  return {\n    x: event.offsetX + paddingLeft + borderLeft,\n    y: event.offsetY + paddingTop + borderTop\n  };\n}\n\nexport function setDragImage( event:DragEvent, dragImage:Element, offsetFunction:DndDragImageOffsetFunction ):void {\n\n  const offset = offsetFunction( event, dragImage ) || {x: 0, y: 0};\n\n  (event.dataTransfer as any).setDragImage( dragImage, offset.x, offset.y );\n}\n","import {\n  CUSTOM_MIME_TYPE,\n  DROP_EFFECTS,\n  filterEffects,\n  getWellKnownMimeType,\n  JSON_MIME_TYPE,\n  MSIE_MIME_TYPE\n} from \"./dnd-utils\";\nimport { DropEffect, EffectAllowed } from \"./dnd-types\";\n\nexport interface DndState {\n  isDragging:boolean;\n  dropEffect?:DropEffect;\n  effectAllowed?:EffectAllowed;\n  type?:string;\n}\n\nconst _dndState:DndState = {\n  isDragging: false,\n  dropEffect: \"none\",\n  effectAllowed: \"all\",\n  type: undefined\n};\n\nexport function startDrag( event:DragEvent, effectAllowed:EffectAllowed, type:string | undefined ) {\n\n  _dndState.isDragging = true;\n  _dndState.dropEffect = \"none\";\n  _dndState.effectAllowed = effectAllowed;\n  _dndState.type = type;\n\n  event.dataTransfer.effectAllowed = effectAllowed;\n}\n\nexport function endDrag() {\n\n  _dndState.isDragging = false;\n  _dndState.dropEffect = undefined;\n  _dndState.effectAllowed = undefined;\n  _dndState.type = undefined;\n}\n\nexport function setDropEffect( event:DragEvent, dropEffect:DropEffect ) {\n\n  if( _dndState.isDragging === true ) {\n\n    _dndState.dropEffect = dropEffect;\n  }\n\n  event.dataTransfer.dropEffect = dropEffect;\n}\n\nexport function getDropEffect( event:DragEvent, effectAllowed?:EffectAllowed | DropEffect ):DropEffect {\n\n  const dataTransferEffectAllowed:EffectAllowed = (event.dataTransfer) ? event.dataTransfer.effectAllowed as EffectAllowed : \"uninitialized\";\n\n  let effects = filterEffects( DROP_EFFECTS, dataTransferEffectAllowed );\n\n  if( _dndState.isDragging === true ) {\n\n    effects = filterEffects( effects, _dndState.effectAllowed );\n  }\n\n  if( effectAllowed ) {\n\n    effects = filterEffects( effects, effectAllowed );\n  }\n\n  // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n  // therefore the following modifier keys will only affect other operating systems.\n  if( effects.length === 0 ) {\n\n    return \"none\";\n  }\n\n  if( event.ctrlKey && effects.indexOf( \"copy\" ) !== -1 ) {\n\n    return \"copy\";\n  }\n\n  if( event.altKey && effects.indexOf( \"link\" ) !== -1 ) {\n\n    return \"link\";\n  }\n\n  return effects[ 0 ] as DropEffect;\n}\n\nexport function getDndType( event:DragEvent ):string | undefined {\n\n  if( _dndState.isDragging === true ) {\n\n    return _dndState.type;\n  }\n\n  const mimeType = getWellKnownMimeType( event );\n\n  if( mimeType === null ) {\n\n    return undefined;\n  }\n\n  if( mimeType === MSIE_MIME_TYPE\n    || mimeType === JSON_MIME_TYPE ) {\n\n    return undefined;\n  }\n\n  return mimeType.substr( CUSTOM_MIME_TYPE.length + 1 ) || undefined;\n}\n\nexport function isExternalDrag():boolean {\n\n  return _dndState.isDragging === false;\n}\n\nexport const dndState:Readonly<DndState> = _dndState as Readonly<DndState>;\n","import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostBinding,\n  HostListener,\n  Input,\n  NgZone,\n  OnDestroy,\n  Output,\n  Renderer2\n} from \"@angular/core\";\nimport { calculateDragImageOffset, DndDragImageOffsetFunction, DndEvent, setDragData, setDragImage } from \"./dnd-utils\";\nimport { DndHandleDirective } from \"./dnd-handle.directive\";\nimport { dndState, endDrag, startDrag } from \"./dnd-state\";\nimport { EffectAllowed } from \"./dnd-types\";\n\n@Directive( {\n  selector: \"[dndDragImageRef]\"\n} )\nexport class DndDragImageRefDirective {\n\n  constructor( parent:DndDraggableDirective,\n               elementRef:ElementRef ) {\n\n    parent.registerDragImage( elementRef );\n  }\n}\n\n@Directive( {\n  selector: \"[dndDraggable]\"\n} )\nexport class DndDraggableDirective implements AfterViewInit, OnDestroy {\n\n  @Input()\n  dndDraggable:any;\n\n  @Input()\n  dndEffectAllowed:EffectAllowed = \"copy\";\n\n  @Input()\n  dndType?:string;\n\n  @Input()\n  dndDraggingClass = \"dndDragging\";\n\n  @Input()\n  dndDraggingSourceClass = \"dndDraggingSource\";\n\n  @Input()\n  dndDraggableDisabledClass = \"dndDraggableDisabled\";\n\n  @Input()\n  dndDragImageOffsetFunction:DndDragImageOffsetFunction = calculateDragImageOffset;\n\n  @Output()\n  readonly dndStart:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndDrag:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndEnd:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndMoved:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndCopied:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndLinked:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndCanceled:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @HostBinding( \"attr.draggable\" )\n  draggable = true;\n\n  private dndHandle?:DndHandleDirective;\n\n  private dndDragImageElementRef?:ElementRef;\n\n  private dragImage:Element;\n\n  private isDragStarted:boolean = false;\n\n  private readonly dragEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDrag( event );\n\n  @Input()\n  set dndDisableIf( value:boolean ) {\n\n    this.draggable = !value;\n\n    if( this.draggable ) {\n\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\n    }\n    else {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\n    }\n  }\n\n  @Input()\n  set dndDisableDragIf( value:boolean ) {\n    this.dndDisableIf = value;\n  }\n\n  constructor( private elementRef:ElementRef,\n               private renderer:Renderer2,\n               private ngZone:NgZone ) {\n  }\n\n  ngAfterViewInit():void {\n    this.ngZone.runOutsideAngular( () => {\n      this.elementRef.nativeElement.addEventListener( \"drag\", this.dragEventHandler );\n    } );\n  }\n\n  ngOnDestroy():void {\n    this.elementRef.nativeElement.removeEventListener( \"drag\", this.dragEventHandler );\n    if(this.isDragStarted === true) {\n      endDrag()\n    }\n  }\n\n  @HostListener( \"dragstart\", [ \"$event\" ] )\n  onDragStart( event:DndEvent ) {\n\n    if( this.draggable === false ) {\n\n      return false;\n    }\n\n    // check if there is dnd handle and if the dnd handle was used to start the drag\n    if( typeof this.dndHandle !== \"undefined\"\n      && typeof event._dndUsingHandle === \"undefined\" ) {\n\n      return false;\n    }\n\n    // initialize global state\n    startDrag( event, this.dndEffectAllowed, this.dndType );\n\n    this.isDragStarted = true;\n\n    setDragData( event, {data: this.dndDraggable, type: this.dndType}, dndState.effectAllowed );\n\n    this.dragImage = this.determineDragImage();\n\n    // set dragging css class prior to setDragImage so styles are applied before\n    // TODO breaking change: add class to elementRef rather than drag image which could be another element\n    this.renderer.addClass( this.dragImage, this.dndDraggingClass );\n\n    // set custom dragimage if present\n    // set dragimage if drag is started from dndHandle\n    if( typeof this.dndDragImageElementRef !== \"undefined\"\n      || typeof event._dndUsingHandle !== \"undefined\" ) {\n\n      setDragImage( event, this.dragImage, this.dndDragImageOffsetFunction );\n    }\n\n    // add dragging source css class on first drag event\n    const unregister = this.renderer.listen( this.elementRef.nativeElement, \"drag\", () => {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\n      unregister();\n    } );\n\n    this.dndStart.emit( event );\n\n    event.stopPropagation();\n  }\n\n  onDrag( event:DragEvent ) {\n\n    this.dndDrag.emit( event );\n  }\n\n  @HostListener( \"dragend\", [ \"$event\" ] )\n  onDragEnd( event:DragEvent ) {\n\n    // get drop effect from custom stored state as its not reliable across browsers\n    const dropEffect = dndState.dropEffect;\n\n    let dropEffectEmitter:EventEmitter<DragEvent>;\n\n    switch( dropEffect ) {\n\n      case \"copy\":\n        dropEffectEmitter = this.dndCopied;\n        break;\n\n      case \"link\":\n        dropEffectEmitter = this.dndLinked;\n        break;\n\n      case \"move\":\n        dropEffectEmitter = this.dndMoved;\n        break;\n\n      default:\n        dropEffectEmitter = this.dndCanceled;\n        break;\n    }\n\n    dropEffectEmitter.emit( event );\n    this.dndEnd.emit( event );\n\n    // reset global state\n    endDrag();\n\n    this.isDragStarted = false;\n\n    this.renderer.removeClass( this.dragImage, this.dndDraggingClass );\n\n    // IE9 special hammering\n    window.setTimeout( () => {\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\n    }, 0 );\n\n    event.stopPropagation();\n  }\n\n  registerDragHandle( handle:DndHandleDirective | undefined ) {\n\n    this.dndHandle = handle;\n  }\n\n  registerDragImage( elementRef:ElementRef | undefined ) {\n\n    this.dndDragImageElementRef = elementRef;\n  }\n\n  private determineDragImage():Element {\n\n    // evaluate custom drag image existence\n    if( typeof this.dndDragImageElementRef !== \"undefined\" ) {\n\n      return this.dndDragImageElementRef.nativeElement as Element;\n    }\n    else {\n\n      return this.elementRef.nativeElement;\n    }\n  }\n}\n","import {\n  AfterViewInit,\n  ContentChild,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostListener,\n  Input,\n  NgZone,\n  OnDestroy,\n  Output,\n  Renderer2\n} from \"@angular/core\";\nimport {\n  DndEvent,\n  DragDropData,\n  getDirectChildElement,\n  getDropData,\n  shouldPositionPlaceholderBeforeElement\n} from \"./dnd-utils\";\nimport { getDndType, getDropEffect, isExternalDrag, setDropEffect } from \"./dnd-state\";\nimport { DropEffect, EffectAllowed } from \"./dnd-types\";\n\nexport interface DndDropEvent {\n  event:DragEvent;\n  dropEffect:DropEffect;\n  isExternal:boolean;\n  data?:any;\n  index?:number;\n  type?:any;\n}\n\n@Directive( {\n  selector: \"[dndPlaceholderRef]\"\n} )\nexport class DndPlaceholderRefDirective {\n\n  constructor( public readonly elementRef:ElementRef ) {\n  }\n}\n\n@Directive( {\n  selector: \"[dndDropzone]\"\n} )\nexport class DndDropzoneDirective implements AfterViewInit, OnDestroy {\n\n  @Input()\n  dndDropzone?:string[];\n\n  @Input()\n  dndEffectAllowed:EffectAllowed;\n\n  @Input()\n  dndAllowExternal:boolean = false;\n\n  @Input()\n  dndHorizontal:boolean = false;\n\n  @Input()\n  dndDragoverClass:string = \"dndDragover\";\n\n  @Input()\n  dndDropzoneDisabledClass = \"dndDropzoneDisabled\";\n\n  @Output()\n  readonly dndDragover:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  @Output()\n  readonly dndDrop:EventEmitter<DndDropEvent> = new EventEmitter<DndDropEvent>();\n\n  @ContentChild( DndPlaceholderRefDirective )\n  private readonly dndPlaceholderRef?:DndPlaceholderRefDirective;\n\n  private placeholder:Element | null = null;\n\n  private disabled:boolean = false;\n\n  private readonly dragEnterEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragEnter( event );\n  private readonly dragOverEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragOver( event );\n  private readonly dragLeaveEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragLeave( event );\n\n  @Input()\n  set dndDisableIf( value:boolean ) {\n\n    this.disabled = !!value;\n\n    if( this.disabled ) {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\n    }\n    else {\n\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\n    }\n  }\n\n  @Input()\n  set dndDisableDropIf( value:boolean ) {\n    this.dndDisableIf = value;\n  }\n\n  constructor( private ngZone:NgZone,\n               private elementRef:ElementRef,\n               private renderer:Renderer2 ) {\n  }\n\n  ngAfterViewInit():void {\n\n    this.placeholder = this.tryGetPlaceholder();\n\n    this.removePlaceholderFromDOM();\n\n    this.ngZone.runOutsideAngular( () => {\n      this.elementRef.nativeElement.addEventListener( \"dragenter\", this.dragEnterEventHandler );\n      this.elementRef.nativeElement.addEventListener( \"dragover\", this.dragOverEventHandler );\n      this.elementRef.nativeElement.addEventListener( \"dragleave\", this.dragLeaveEventHandler );\n    } );\n  }\n\n  ngOnDestroy():void {\n    this.elementRef.nativeElement.removeEventListener( \"dragenter\", this.dragEnterEventHandler );\n    this.elementRef.nativeElement.removeEventListener( \"dragover\", this.dragOverEventHandler );\n    this.elementRef.nativeElement.removeEventListener( \"dragleave\", this.dragLeaveEventHandler );\n  }\n\n  onDragEnter( event:DndEvent ) {\n\n    // check if another dropzone is activated\n    if( event._dndDropzoneActive === true ) {\n\n      this.cleanupDragoverState();\n      return;\n    }\n\n    // set as active if the target element is inside this dropzone\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\n\n      const newTarget = document.elementFromPoint( event.clientX, event.clientY );\n\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\n\n        event._dndDropzoneActive = true;\n      }\n    }\n\n    // check if this drag event is allowed to drop on this dropzone\n    const type = getDndType( event );\n    if( this.isDropAllowed( type ) === false ) {\n\n      return;\n    }\n\n    // allow the dragenter\n    event.preventDefault();\n  }\n\n  onDragOver( event:DragEvent ) {\n    // With nested dropzones, we want to ignore this event if a child dropzone\n    // has already handled a dragover.  Historically, event.stopPropagation() was\n    // used to prevent this bubbling, but that prevents any dragovers outside the\n    // ngx-drag-drop component, and stops other use cases such as scrolling on drag.\n    // Instead, we can check if the event was already prevented by a child and bail early.\n    if( event.defaultPrevented ) {\n\n      return;\n    }\n\n    // check if this drag event is allowed to drop on this dropzone\n    const type = getDndType( event );\n    if( this.isDropAllowed( type ) === false ) {\n\n      return;\n    }\n\n    this.checkAndUpdatePlaceholderPosition( event );\n\n    const dropEffect = getDropEffect( event, this.dndEffectAllowed );\n\n    if( dropEffect === \"none\" ) {\n\n      this.cleanupDragoverState();\n      return;\n    }\n\n    // allow the dragover\n    event.preventDefault();\n\n    // set the drop effect\n    setDropEffect( event, dropEffect );\n\n    this.dndDragover.emit( event );\n\n    this.renderer.addClass( this.elementRef.nativeElement, this.dndDragoverClass );\n  }\n\n  @HostListener( \"drop\", [ \"$event\" ] )\n  onDrop( event:DragEvent ) {\n\n    try {\n\n      // check if this drag event is allowed to drop on this dropzone\n      const type = getDndType( event );\n      if( this.isDropAllowed( type ) === false ) {\n\n        return;\n      }\n\n      const data:DragDropData = getDropData( event, isExternalDrag() );\n\n      if( this.isDropAllowed( data.type ) === false ) {\n\n        return;\n      }\n\n      // signal custom drop handling\n      event.preventDefault();\n\n      const dropEffect = getDropEffect( event );\n\n      setDropEffect( event, dropEffect );\n\n      if( dropEffect === \"none\" ) {\n\n        return;\n      }\n\n      const dropIndex = this.getPlaceholderIndex();\n\n      // if for whatever reason the placeholder is not present in the DOM but it should be there\n      // we don't allow/emit the drop event since it breaks the contract\n      // seems to only happen if drag and drop is executed faster than the DOM updates\n      if( dropIndex === -1 ) {\n\n        return;\n      }\n\n      this.dndDrop.emit( {\n        event: event,\n        dropEffect: dropEffect,\n        isExternal: isExternalDrag(),\n        data: data.data,\n        index: dropIndex,\n        type: type,\n      } );\n\n      event.stopPropagation();\n\n    }\n    finally {\n\n      this.cleanupDragoverState();\n    }\n  }\n\n  onDragLeave( event:DndEvent ) {\n\n    // check if still inside this dropzone and not yet handled by another dropzone\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\n\n      const newTarget = document.elementFromPoint( event.clientX, event.clientY );\n\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\n\n        event._dndDropzoneActive = true;\n        return;\n      }\n    }\n\n    this.cleanupDragoverState();\n\n    // cleanup drop effect when leaving dropzone\n    setDropEffect( event, \"none\" );\n  }\n\n  private isDropAllowed( type?:string ):boolean {\n\n    // dropzone is disabled -> deny it\n    if( this.disabled === true ) {\n\n      return false;\n    }\n\n    // if drag did not start from our directive\n    // and external drag sources are not allowed -> deny it\n    if( isExternalDrag() === true\n      && this.dndAllowExternal === false ) {\n\n      return false;\n    }\n\n    // no filtering by types -> allow it\n    if( !this.dndDropzone ) {\n\n      return true;\n    }\n\n    // no type set -> allow it\n    if( !type ) {\n\n      return true;\n    }\n\n    if( Array.isArray( this.dndDropzone ) === false ) {\n\n      throw new Error( \"dndDropzone: bound value to [dndDropzone] must be an array!\" );\n    }\n\n    // if dropzone contains type -> allow it\n    return this.dndDropzone.indexOf( type ) !== -1;\n  }\n\n  private tryGetPlaceholder():Element | null {\n\n    if( typeof this.dndPlaceholderRef !== \"undefined\" ) {\n\n      return this.dndPlaceholderRef.elementRef.nativeElement as Element;\n    }\n\n    // TODO nasty workaround needed because if ng-container / template is used @ContentChild() or DI will fail because\n    // of wrong context see angular bug https://github.com/angular/angular/issues/13517\n    return this.elementRef.nativeElement.querySelector( \"[dndPlaceholderRef]\" );\n  }\n\n  private removePlaceholderFromDOM() {\n\n    if( this.placeholder !== null\n      && this.placeholder.parentNode !== null ) {\n      this.placeholder.parentNode.removeChild( this.placeholder );\n    }\n  }\n\n  private checkAndUpdatePlaceholderPosition( event:DragEvent ):void {\n\n    if( this.placeholder === null ) {\n\n      return;\n    }\n\n    // make sure the placeholder is in the DOM\n    if( this.placeholder.parentNode !== this.elementRef.nativeElement ) {\n\n      this.renderer.appendChild( this.elementRef.nativeElement, this.placeholder );\n    }\n\n    // update the position if the event originates from a child element of the dropzone\n    const directChild = getDirectChildElement( this.elementRef.nativeElement, event.target as Element );\n\n    // early exit if no direct child or direct child is placeholder\n    if( directChild === null\n      || directChild === this.placeholder ) {\n\n      return;\n    }\n\n    const positionPlaceholderBeforeDirectChild = shouldPositionPlaceholderBeforeElement( event, directChild, this.dndHorizontal );\n\n    if( positionPlaceholderBeforeDirectChild ) {\n\n      // do insert before only if necessary\n      if( directChild.previousSibling !== this.placeholder ) {\n\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild );\n      }\n    }\n    else {\n\n      // do insert after only if necessary\n      if( directChild.nextSibling !== this.placeholder ) {\n\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild.nextSibling );\n      }\n    }\n  }\n\n  private getPlaceholderIndex():number | undefined {\n\n    if( this.placeholder === null ) {\n\n      return undefined;\n    }\n\n    const element = this.elementRef.nativeElement as HTMLElement;\n\n    return Array.prototype.indexOf.call( element.children, this.placeholder );\n  }\n\n  private cleanupDragoverState() {\n\n    this.renderer.removeClass( this.elementRef.nativeElement, this.dndDragoverClass );\n\n    this.removePlaceholderFromDOM();\n  }\n}\n","import { Directive, HostBinding, HostListener } from \"@angular/core\";\nimport { DndEvent } from \"./dnd-utils\";\nimport { DndDraggableDirective } from \"./dnd-draggable.directive\";\n\n@Directive( {\n  selector: \"[dndHandle]\"\n} )\nexport class DndHandleDirective {\n\n  @HostBinding( \"attr.draggable\" )\n  draggable = true;\n\n  constructor( parent:DndDraggableDirective ) {\n\n    parent.registerDragHandle( this );\n  }\n\n  @HostListener( \"dragstart\", [ \"$event\" ] )\n  @HostListener( \"dragend\", [ \"$event\" ] )\n  onDragEvent( event:DndEvent ) {\n\n    event._dndUsingHandle = true;\n  }\n}\n","import { NgModule } from \"@angular/core\";\nimport { CommonModule } from \"@angular/common\";\nimport { DndDraggableDirective, DndDragImageRefDirective } from \"./dnd-draggable.directive\";\nimport { DndDropzoneDirective, DndPlaceholderRefDirective } from \"./dnd-dropzone.directive\";\nimport { DndHandleDirective } from \"./dnd-handle.directive\";\n\n@NgModule( {\n  imports: [\n    CommonModule\n  ],\n  declarations: [\n    DndDraggableDirective,\n    DndDropzoneDirective,\n    DndHandleDirective,\n    DndPlaceholderRefDirective,\n    DndDragImageRefDirective\n  ],\n  exports: [\n    DndDraggableDirective,\n    DndDropzoneDirective,\n    DndHandleDirective,\n    DndPlaceholderRefDirective,\n    DndDragImageRefDirective\n  ]\n} )\nexport class DndModule {\n}\n"]},"metadata":{},"sourceType":"module"}