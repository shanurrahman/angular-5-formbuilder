{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/shanur/Documents/personal/angular-5-formbuilder/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/home/shanur/Documents/personal/angular-5-formbuilder/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/shanur/Documents/personal/angular-5-formbuilder/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/shanur/Documents/personal/angular-5-formbuilder/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Injectable, InjectionToken } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport * as Éµngcc0 from '@angular/core';\n\nvar NzTreeNode = /*#__PURE__*/function () {\n  /**\n   * Init nzTreeNode\n   * @param option: user's input\n   * @param parent\n   * @param service: base nzTreeService\n   */\n  function NzTreeNode(option) {\n    var _this = this;\n\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var service = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, NzTreeNode);\n\n    this._title = '';\n    this.level = 0; // Parent Node\n\n    this.parentNode = null;\n    this._icon = '';\n    this._children = [];\n    this._isLeaf = false;\n    this._isChecked = false;\n    this._isSelectable = false;\n    this._isDisabled = false;\n    this._isDisableCheckbox = false;\n    this._isExpanded = false;\n    this._isHalfChecked = false;\n    this._isSelected = false;\n    this._isLoading = false;\n    this.canHide = false;\n    this.isMatched = false;\n    this.service = null;\n\n    if (option instanceof NzTreeNode) {\n      return option;\n    }\n\n    this.service = service || null;\n    this.origin = option;\n    this.key = option.key;\n    this.parentNode = parent;\n    this._title = option.title || '---';\n    this._icon = option.icon || '';\n    this._isLeaf = option.isLeaf || false;\n    this._children = []; // option params\n\n    this._isChecked = option.checked || false;\n    this._isSelectable = option.disabled || option.selectable !== false;\n    this._isDisabled = option.disabled || false;\n    this._isDisableCheckbox = option.disableCheckbox || false;\n    this._isExpanded = option.isLeaf ? false : option.expanded || false;\n    this._isHalfChecked = false;\n    this._isSelected = !option.disabled && option.selected || false;\n    this._isLoading = false;\n    this.isMatched = false;\n    /**\n     * parent's checked status will affect children while initializing\n     */\n\n    if (parent) {\n      this.level = parent.level + 1;\n    } else {\n      this.level = 0;\n    }\n\n    if (typeof option.children !== 'undefined' && option.children !== null) {\n      option.children.forEach(function (nodeOptions) {\n        var s = _this.treeService;\n\n        if (s && !s.isCheckStrictly && option.checked && !option.disabled && !nodeOptions.disabled && !nodeOptions.disableCheckbox) {\n          nodeOptions.checked = option.checked;\n        }\n\n        _this._children.push(new NzTreeNode(nodeOptions, _this));\n      });\n    }\n  }\n\n  _createClass(NzTreeNode, [{\n    key: \"setSyncChecked\",\n    value: function setSyncChecked() {\n      var checked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var halfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.setChecked(checked, halfChecked);\n\n      if (this.treeService && !this.treeService.isCheckStrictly) {\n        this.treeService.conduct(this);\n      }\n    }\n  }, {\n    key: \"setChecked\",\n    value: function setChecked() {\n      var checked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var halfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.origin.checked = checked;\n      this.isChecked = checked;\n      this.isHalfChecked = halfChecked;\n    }\n  }, {\n    key: \"setExpanded\",\n    value: function setExpanded(value) {\n      this._isExpanded = value;\n      this.origin.expanded = value;\n      this.afterValueChange('isExpanded');\n    }\n  }, {\n    key: \"getParentNode\",\n    value: function getParentNode() {\n      return this.parentNode;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      return this.children;\n    }\n    /**\n     * Support appending child nodes by position. Leaf node cannot be appended.\n     */\n\n  }, {\n    key: \"addChildren\",\n    value: function addChildren(children) {\n      var _this2 = this;\n\n      var childPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n      if (!this.isLeaf) {\n        children.forEach(function (node) {\n          var refreshLevel = function refreshLevel(n) {\n            n.getChildren().forEach(function (c) {\n              c.level = c.getParentNode().level + 1; // flush origin\n\n              c.origin.level = c.level;\n              refreshLevel(c);\n            });\n          };\n\n          var child = node;\n\n          if (child instanceof NzTreeNode) {\n            child.parentNode = _this2;\n          } else {\n            child = new NzTreeNode(node, _this2);\n          }\n\n          child.level = _this2.level + 1;\n          child.origin.level = child.level;\n          refreshLevel(child);\n\n          try {\n            childPos === -1 ? _this2.children.push(child) : _this2.children.splice(childPos, 0, child); // flush origin\n          } catch (e) {}\n        });\n        this.origin.children = this.getChildren().map(function (v) {\n          return v.origin;\n        }); // remove loading state\n\n        this.isLoading = false;\n      }\n\n      this.afterValueChange('addChildren');\n      this.afterValueChange('reRender');\n    }\n  }, {\n    key: \"clearChildren\",\n    value: function clearChildren() {\n      // refresh checked state\n      this.afterValueChange('clearChildren');\n      this.children = [];\n      this.origin.children = [];\n      this.afterValueChange('reRender');\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var _this3 = this;\n\n      var parentNode = this.getParentNode();\n\n      if (parentNode) {\n        parentNode.children = parentNode.getChildren().filter(function (v) {\n          return v.key !== _this3.key;\n        });\n        parentNode.origin.children = parentNode.origin.children.filter(function (v) {\n          return v.key !== _this3.key;\n        });\n        this.afterValueChange('remove');\n        this.afterValueChange('reRender');\n      }\n    }\n  }, {\n    key: \"afterValueChange\",\n    value: function afterValueChange(key) {\n      if (this.treeService) {\n        switch (key) {\n          case 'isChecked':\n            this.treeService.setCheckedNodeList(this);\n            break;\n\n          case 'isHalfChecked':\n            this.treeService.setHalfCheckedNodeList(this);\n            break;\n\n          case 'isExpanded':\n            this.treeService.setExpandedNodeList(this);\n            break;\n\n          case 'isSelected':\n            this.treeService.setNodeActive(this);\n            break;\n\n          case 'clearChildren':\n            this.treeService.afterRemove(this.getChildren());\n            break;\n\n          case 'remove':\n            this.treeService.afterRemove([this]);\n            break;\n\n          case 'reRender':\n            this.treeService.flattenTreeData(this.treeService.rootNodes, this.treeService.getExpandedNodeList().map(function (v) {\n              return v.key;\n            }));\n            break;\n        }\n      }\n\n      this.update();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.component) {\n        this.component.markForCheck();\n      }\n    }\n  }, {\n    key: \"treeService\",\n    get: function get() {\n      return this.service || this.parentNode && this.parentNode.treeService;\n    }\n    /**\n     * auto generate\n     * get\n     * set\n     */\n\n  }, {\n    key: \"title\",\n    get: function get() {\n      return this._title;\n    },\n    set: function set(value) {\n      this._title = value;\n      this.update();\n    }\n  }, {\n    key: \"icon\",\n    get: function get() {\n      return this._icon;\n    },\n    set: function set(value) {\n      this._icon = value;\n      this.update();\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._children;\n    },\n    set: function set(value) {\n      this._children = value;\n      this.update();\n    }\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this._isLeaf;\n    },\n    set: function set(value) {\n      this._isLeaf = value;\n      this.update();\n    }\n  }, {\n    key: \"isChecked\",\n    get: function get() {\n      return this._isChecked;\n    },\n    set: function set(value) {\n      this._isChecked = value;\n      this.origin.checked = value;\n      this.afterValueChange('isChecked');\n    }\n  }, {\n    key: \"isHalfChecked\",\n    get: function get() {\n      return this._isHalfChecked;\n    },\n    set: function set(value) {\n      this._isHalfChecked = value;\n      this.afterValueChange('isHalfChecked');\n    }\n  }, {\n    key: \"isSelectable\",\n    get: function get() {\n      return this._isSelectable;\n    },\n    set: function set(value) {\n      this._isSelectable = value;\n      this.update();\n    }\n  }, {\n    key: \"isDisabled\",\n    get: function get() {\n      return this._isDisabled;\n    },\n    set: function set(value) {\n      this._isDisabled = value;\n      this.update();\n    }\n  }, {\n    key: \"isDisableCheckbox\",\n    get: function get() {\n      return this._isDisableCheckbox;\n    },\n    set: function set(value) {\n      this._isDisableCheckbox = value;\n      this.update();\n    }\n  }, {\n    key: \"isExpanded\",\n    get: function get() {\n      return this._isExpanded;\n    },\n    set: function set(value) {\n      this._isExpanded = value;\n      this.origin.expanded = value;\n      this.afterValueChange('isExpanded');\n      this.afterValueChange('reRender');\n    }\n  }, {\n    key: \"isSelected\",\n    get: function get() {\n      return this._isSelected;\n    },\n    set: function set(value) {\n      this._isSelected = value;\n      this.origin.selected = value;\n      this.afterValueChange('isSelected');\n    }\n  }, {\n    key: \"isLoading\",\n    get: function get() {\n      return this._isLoading;\n    },\n    set: function set(value) {\n      this._isLoading = value;\n      this.update();\n    }\n  }]);\n\n  return NzTreeNode;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction isCheckDisabled(node) {\n  var isDisabled = node.isDisabled,\n      isDisableCheckbox = node.isDisableCheckbox;\n  return !!(isDisabled || isDisableCheckbox);\n}\n\nfunction isInArray(needle, haystack) {\n  return haystack.length > 0 && haystack.indexOf(needle) > -1;\n}\n\nfunction getPosition(level, index) {\n  return \"\".concat(level, \"-\").concat(index);\n}\n\nfunction getKey(key, pos) {\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  return pos;\n}\n/**\n * Flat nest tree data into flatten list. This is used for virtual list render.\n * @param treeNodeList Origin data node list\n * @param expandedKeys\n * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).\n */\n\n\nfunction _flattenTreeData() {\n  var treeNodeList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var expandedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);\n  var flattenList = [];\n\n  function dig(list) {\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return list.map(function (treeNode, index) {\n      var pos = getPosition(parent ? parent.pos : '0', index);\n      var mergedKey = getKey(treeNode.key, pos);\n      treeNode.isStart = [].concat(_toConsumableArray(parent ? parent.isStart : []), [index === 0]);\n      treeNode.isEnd = [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index === list.length - 1]); // Add FlattenDataNode into list\n      // TODO: only need data here.\n\n      var flattenNode = {\n        parent: parent,\n        pos: pos,\n        children: [],\n        data: treeNode,\n        isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index === 0]),\n        isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index === list.length - 1])\n      };\n      flattenList.push(flattenNode); // Loop treeNode children\n\n      if (expandedKeys === true || expandedKeySet.has(mergedKey) || treeNode.isExpanded) {\n        flattenNode.children = dig(treeNode.children || [], flattenNode);\n      } else {\n        flattenNode.children = [];\n      }\n\n      return flattenNode;\n    });\n  }\n\n  dig(treeNodeList);\n  return flattenList;\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar NzTreeBaseService = /*#__PURE__*/function () {\n  function NzTreeBaseService() {\n    _classCallCheck(this, NzTreeBaseService);\n\n    this.DRAG_SIDE_RANGE = 0.25;\n    this.DRAG_MIN_GAP = 2;\n    this.isCheckStrictly = false;\n    this.isMultiple = false;\n    this.rootNodes = [];\n    this.flattenNodes$ = new BehaviorSubject([]);\n    this.selectedNodeList = [];\n    this.expandedNodeList = [];\n    this.checkedNodeList = [];\n    this.halfCheckedNodeList = [];\n    this.matchedNodeList = [];\n  }\n  /**\n   * reset tree nodes will clear default node list\n   */\n\n\n  _createClass(NzTreeBaseService, [{\n    key: \"initTree\",\n    value: function initTree(nzNodes) {\n      this.rootNodes = nzNodes;\n      this.expandedNodeList = [];\n      this.selectedNodeList = [];\n      this.halfCheckedNodeList = [];\n      this.checkedNodeList = [];\n      this.matchedNodeList = [];\n    }\n  }, {\n    key: \"flattenTreeData\",\n    value: function flattenTreeData(nzNodes) {\n      var expandedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      this.flattenNodes$.next(_flattenTreeData(nzNodes, expandedKeys).map(function (item) {\n        return item.data;\n      }));\n    }\n  }, {\n    key: \"getSelectedNode\",\n    value: function getSelectedNode() {\n      return this.selectedNode;\n    }\n    /**\n     * get some list\n     */\n\n  }, {\n    key: \"getSelectedNodeList\",\n    value: function getSelectedNodeList() {\n      return this.conductNodeState('select');\n    }\n    /**\n     * return checked nodes\n     */\n\n  }, {\n    key: \"getCheckedNodeList\",\n    value: function getCheckedNodeList() {\n      return this.conductNodeState('check');\n    }\n  }, {\n    key: \"getHalfCheckedNodeList\",\n    value: function getHalfCheckedNodeList() {\n      return this.conductNodeState('halfCheck');\n    }\n    /**\n     * return expanded nodes\n     */\n\n  }, {\n    key: \"getExpandedNodeList\",\n    value: function getExpandedNodeList() {\n      return this.conductNodeState('expand');\n    }\n    /**\n     * return search matched nodes\n     */\n\n  }, {\n    key: \"getMatchedNodeList\",\n    value: function getMatchedNodeList() {\n      return this.conductNodeState('match');\n    }\n  }, {\n    key: \"isArrayOfNzTreeNode\",\n    value: function isArrayOfNzTreeNode(value) {\n      return value.every(function (item) {\n        return item instanceof NzTreeNode;\n      });\n    }\n    /**\n     * set drag node\n     */\n\n  }, {\n    key: \"setSelectedNode\",\n    value: function setSelectedNode(node) {\n      this.selectedNode = node;\n    }\n    /**\n     * set node selected status\n     */\n\n  }, {\n    key: \"setNodeActive\",\n    value: function setNodeActive(node) {\n      if (!this.isMultiple && node.isSelected) {\n        this.selectedNodeList.forEach(function (n) {\n          if (node.key !== n.key) {\n            // reset other nodes\n            n.isSelected = false;\n          }\n        }); // single mode: remove pre node\n\n        this.selectedNodeList = [];\n      }\n\n      this.setSelectedNodeList(node, this.isMultiple);\n    }\n    /**\n     * add or remove node to selectedNodeList\n     */\n\n  }, {\n    key: \"setSelectedNodeList\",\n    value: function setSelectedNodeList(node) {\n      var isMultiple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var index = this.getIndexOfArray(this.selectedNodeList, node.key);\n\n      if (isMultiple) {\n        if (node.isSelected && index === -1) {\n          this.selectedNodeList.push(node);\n        }\n      } else {\n        if (node.isSelected && index === -1) {\n          this.selectedNodeList = [node];\n        }\n      }\n\n      if (!node.isSelected) {\n        this.selectedNodeList = this.selectedNodeList.filter(function (n) {\n          return n.key !== node.key;\n        });\n      }\n    }\n    /**\n     * merge checked nodes\n     */\n\n  }, {\n    key: \"setHalfCheckedNodeList\",\n    value: function setHalfCheckedNodeList(node) {\n      var index = this.getIndexOfArray(this.halfCheckedNodeList, node.key);\n\n      if (node.isHalfChecked && index === -1) {\n        this.halfCheckedNodeList.push(node);\n      } else if (!node.isHalfChecked && index > -1) {\n        this.halfCheckedNodeList = this.halfCheckedNodeList.filter(function (n) {\n          return node.key !== n.key;\n        });\n      }\n    }\n  }, {\n    key: \"setCheckedNodeList\",\n    value: function setCheckedNodeList(node) {\n      var index = this.getIndexOfArray(this.checkedNodeList, node.key);\n\n      if (node.isChecked && index === -1) {\n        this.checkedNodeList.push(node);\n      } else if (!node.isChecked && index > -1) {\n        this.checkedNodeList = this.checkedNodeList.filter(function (n) {\n          return node.key !== n.key;\n        });\n      }\n    }\n    /**\n     * conduct checked/selected/expanded keys\n     */\n\n  }, {\n    key: \"conductNodeState\",\n    value: function conductNodeState() {\n      var _this4 = this;\n\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'check';\n      var resultNodesList = [];\n\n      switch (type) {\n        case 'select':\n          resultNodesList = this.selectedNodeList;\n          break;\n\n        case 'expand':\n          resultNodesList = this.expandedNodeList;\n          break;\n\n        case 'match':\n          resultNodesList = this.matchedNodeList;\n          break;\n\n        case 'check':\n          resultNodesList = this.checkedNodeList;\n\n          var isIgnore = function isIgnore(node) {\n            var parentNode = node.getParentNode();\n\n            if (parentNode) {\n              if (_this4.checkedNodeList.findIndex(function (n) {\n                return n.key === parentNode.key;\n              }) > -1) {\n                return true;\n              } else {\n                return isIgnore(parentNode);\n              }\n            }\n\n            return false;\n          }; // merge checked\n\n\n          if (!this.isCheckStrictly) {\n            resultNodesList = this.checkedNodeList.filter(function (n) {\n              return !isIgnore(n);\n            });\n          }\n\n          break;\n\n        case 'halfCheck':\n          if (!this.isCheckStrictly) {\n            resultNodesList = this.halfCheckedNodeList;\n          }\n\n          break;\n      }\n\n      return resultNodesList;\n    }\n    /**\n     * set expanded nodes\n     */\n\n  }, {\n    key: \"setExpandedNodeList\",\n    value: function setExpandedNodeList(node) {\n      if (node.isLeaf) {\n        return;\n      }\n\n      var index = this.getIndexOfArray(this.expandedNodeList, node.key);\n\n      if (node.isExpanded && index === -1) {\n        this.expandedNodeList.push(node);\n      } else if (!node.isExpanded && index > -1) {\n        this.expandedNodeList.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"setMatchedNodeList\",\n    value: function setMatchedNodeList(node) {\n      var index = this.getIndexOfArray(this.matchedNodeList, node.key);\n\n      if (node.isMatched && index === -1) {\n        this.matchedNodeList.push(node);\n      } else if (!node.isMatched && index > -1) {\n        this.matchedNodeList.splice(index, 1);\n      }\n    }\n    /**\n     * check state\n     * @param isCheckStrictly\n     */\n\n  }, {\n    key: \"refreshCheckState\",\n    value: function refreshCheckState() {\n      var _this5 = this;\n\n      var isCheckStrictly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (isCheckStrictly) {\n        return;\n      }\n\n      this.checkedNodeList.forEach(function (node) {\n        _this5.conduct(node, isCheckStrictly);\n      });\n    } // reset other node checked state based current node\n\n  }, {\n    key: \"conduct\",\n    value: function conduct(node) {\n      var isCheckStrictly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var isChecked = node.isChecked;\n\n      if (node && !isCheckStrictly) {\n        this.conductUp(node);\n        this.conductDown(node, isChecked);\n      }\n    }\n    /**\n     * 1ãchildren half checked\n     * 2ãchildren all checked, parent checked\n     * 3ãno children checked\n     */\n\n  }, {\n    key: \"conductUp\",\n    value: function conductUp(node) {\n      var parentNode = node.getParentNode();\n\n      if (parentNode) {\n        if (!isCheckDisabled(parentNode)) {\n          if (parentNode.children.every(function (child) {\n            return isCheckDisabled(child) || !child.isHalfChecked && child.isChecked;\n          })) {\n            parentNode.isChecked = true;\n            parentNode.isHalfChecked = false;\n          } else if (parentNode.children.some(function (child) {\n            return child.isHalfChecked || child.isChecked;\n          })) {\n            parentNode.isChecked = false;\n            parentNode.isHalfChecked = true;\n          } else {\n            parentNode.isChecked = false;\n            parentNode.isHalfChecked = false;\n          }\n        }\n\n        this.setCheckedNodeList(parentNode);\n        this.setHalfCheckedNodeList(parentNode);\n        this.conductUp(parentNode);\n      }\n    }\n    /**\n     * reset child check state\n     */\n\n  }, {\n    key: \"conductDown\",\n    value: function conductDown(node, value) {\n      var _this6 = this;\n\n      if (!isCheckDisabled(node)) {\n        node.isChecked = value;\n        node.isHalfChecked = false;\n        this.setCheckedNodeList(node);\n        this.setHalfCheckedNodeList(node);\n        node.children.forEach(function (n) {\n          _this6.conductDown(n, value);\n        });\n      }\n    }\n    /**\n     * flush after delete node\n     */\n\n  }, {\n    key: \"afterRemove\",\n    value: function afterRemove(nodes) {\n      var _this7 = this;\n\n      // to reset selectedNodeList & expandedNodeList\n      var loopNode = function loopNode(node) {\n        // remove selected node\n        _this7.selectedNodeList = _this7.selectedNodeList.filter(function (n) {\n          return n.key !== node.key;\n        }); // remove expanded node\n\n        _this7.expandedNodeList = _this7.expandedNodeList.filter(function (n) {\n          return n.key !== node.key;\n        }); // remove checked node\n\n        _this7.checkedNodeList = _this7.checkedNodeList.filter(function (n) {\n          return n.key !== node.key;\n        });\n\n        if (node.children) {\n          node.children.forEach(function (child) {\n            loopNode(child);\n          });\n        }\n      };\n\n      nodes.forEach(function (n) {\n        loopNode(n);\n      });\n      this.refreshCheckState(this.isCheckStrictly);\n    }\n    /**\n     * drag event\n     */\n\n  }, {\n    key: \"refreshDragNode\",\n    value: function refreshDragNode(node) {\n      var _this8 = this;\n\n      if (node.children.length === 0) {\n        // until root\n        this.conductUp(node);\n      } else {\n        node.children.forEach(function (child) {\n          _this8.refreshDragNode(child);\n        });\n      }\n    } // reset node level\n\n  }, {\n    key: \"resetNodeLevel\",\n    value: function resetNodeLevel(node) {\n      var parentNode = node.getParentNode();\n\n      if (parentNode) {\n        node.level = parentNode.level + 1;\n      } else {\n        node.level = 0;\n      }\n\n      var _iterator = _createForOfIteratorHelper(node.children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          this.resetNodeLevel(child);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"calcDropPosition\",\n    value: function calcDropPosition(event) {\n      var clientY = event.clientY; // to fix firefox undefined\n\n      var _event$target$getBoun = event.target.getBoundingClientRect(),\n          top = _event$target$getBoun.top,\n          bottom = _event$target$getBoun.bottom,\n          height = _event$target$getBoun.height;\n\n      var des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);\n\n      if (clientY <= top + des) {\n        return -1;\n      } else if (clientY >= bottom - des) {\n        return 1;\n      }\n\n      return 0;\n    }\n    /**\n     * drop\n     * 0: inner -1: pre 1: next\n     */\n\n  }, {\n    key: \"dropAndApply\",\n    value: function dropAndApply(targetNode) {\n      var _this9 = this;\n\n      var dragPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n      if (!targetNode || dragPos > 1) {\n        return;\n      }\n\n      var treeService = targetNode.treeService;\n      var targetParent = targetNode.getParentNode();\n      var isSelectedRootNode = this.selectedNode.getParentNode(); // remove the dragNode\n\n      if (isSelectedRootNode) {\n        isSelectedRootNode.children = isSelectedRootNode.children.filter(function (n) {\n          return n.key !== _this9.selectedNode.key;\n        });\n      } else {\n        this.rootNodes = this.rootNodes.filter(function (n) {\n          return n.key !== _this9.selectedNode.key;\n        });\n      }\n\n      switch (dragPos) {\n        case 0:\n          targetNode.addChildren([this.selectedNode]);\n          this.resetNodeLevel(targetNode);\n          break;\n\n        case -1:\n        case 1:\n          var tIndex = dragPos === 1 ? 1 : 0;\n\n          if (targetParent) {\n            targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);\n            var parentNode = this.selectedNode.getParentNode();\n\n            if (parentNode) {\n              this.resetNodeLevel(parentNode);\n            }\n          } else {\n            var targetIndex = this.rootNodes.indexOf(targetNode) + tIndex; // Insert root node.\n\n            this.rootNodes.splice(targetIndex, 0, this.selectedNode);\n            this.rootNodes[targetIndex].parentNode = null;\n            this.resetNodeLevel(this.rootNodes[targetIndex]);\n          }\n\n          break;\n      } // flush all nodes\n\n\n      this.rootNodes.forEach(function (child) {\n        if (!child.treeService) {\n          child.service = treeService;\n        }\n\n        _this9.refreshDragNode(child);\n      });\n    }\n    /**\n     * emit Structure\n     * eventName\n     * node\n     * event: MouseEvent / DragEvent\n     * dragNode\n     */\n\n  }, {\n    key: \"formatEvent\",\n    value: function formatEvent(eventName, node, event) {\n      var emitStructure = {\n        eventName: eventName,\n        node: node,\n        event: event\n      };\n\n      switch (eventName) {\n        case 'dragstart':\n        case 'dragenter':\n        case 'dragover':\n        case 'dragleave':\n        case 'drop':\n        case 'dragend':\n          Object.assign(emitStructure, {\n            dragNode: this.getSelectedNode()\n          });\n          break;\n\n        case 'click':\n        case 'dblclick':\n          Object.assign(emitStructure, {\n            selectedKeys: this.selectedNodeList\n          });\n          Object.assign(emitStructure, {\n            nodes: this.selectedNodeList\n          });\n          Object.assign(emitStructure, {\n            keys: this.selectedNodeList.map(function (n) {\n              return n.key;\n            })\n          });\n          break;\n\n        case 'check':\n          var checkedNodeList = this.getCheckedNodeList();\n          Object.assign(emitStructure, {\n            checkedKeys: checkedNodeList\n          });\n          Object.assign(emitStructure, {\n            nodes: checkedNodeList\n          });\n          Object.assign(emitStructure, {\n            keys: checkedNodeList.map(function (n) {\n              return n.key;\n            })\n          });\n          break;\n\n        case 'search':\n          Object.assign(emitStructure, {\n            matchedKeys: this.getMatchedNodeList()\n          });\n          Object.assign(emitStructure, {\n            nodes: this.getMatchedNodeList()\n          });\n          Object.assign(emitStructure, {\n            keys: this.getMatchedNodeList().map(function (n) {\n              return n.key;\n            })\n          });\n          break;\n\n        case 'expand':\n          Object.assign(emitStructure, {\n            nodes: this.expandedNodeList\n          });\n          Object.assign(emitStructure, {\n            keys: this.expandedNodeList.map(function (n) {\n              return n.key;\n            })\n          });\n          break;\n      }\n\n      return emitStructure;\n    }\n    /**\n     * New functions for flatten nodes\n     */\n\n  }, {\n    key: \"getIndexOfArray\",\n    value: function getIndexOfArray(list, key) {\n      return list.findIndex(function (v) {\n        return v.key === key;\n      });\n    }\n    /**\n     * Render by nzCheckedKeys\n     * When keys equals null, just render with checkStrictly\n     * @param keys\n     * @param checkStrictly\n     */\n\n  }, {\n    key: \"conductCheck\",\n    value: function conductCheck(keys, checkStrictly) {\n      this.checkedNodeList = [];\n      this.halfCheckedNodeList = [];\n\n      var calc = function calc(nodes) {\n        nodes.forEach(function (node) {\n          if (keys === null) {\n            // render tree if no default checked keys found\n            node.isChecked = !!node.origin.checked;\n          } else {\n            if (isInArray(node.key, keys || [])) {\n              node.isChecked = true;\n              node.isHalfChecked = false;\n            } else {\n              node.isChecked = false;\n              node.isHalfChecked = false;\n            }\n          }\n\n          if (node.children.length > 0) {\n            calc(node.children);\n          }\n        });\n      };\n\n      calc(this.rootNodes);\n      this.refreshCheckState(checkStrictly);\n    }\n  }, {\n    key: \"conductExpandedKeys\",\n    value: function conductExpandedKeys() {\n      var _this10 = this;\n\n      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var expandedKeySet = new Set(keys === true ? [] : keys);\n      this.expandedNodeList = [];\n\n      var calc = function calc(nodes) {\n        nodes.forEach(function (node) {\n          node.setExpanded(keys === true || expandedKeySet.has(node.key) || node.isExpanded === true);\n\n          if (node.isExpanded) {\n            _this10.setExpandedNodeList(node);\n          }\n\n          if (node.children.length > 0) {\n            calc(node.children);\n          }\n        });\n      };\n\n      calc(this.rootNodes);\n    }\n  }, {\n    key: \"conductSelectedKeys\",\n    value: function conductSelectedKeys(keys, isMulti) {\n      var _this11 = this;\n\n      this.selectedNodeList.forEach(function (node) {\n        return node.isSelected = false;\n      });\n      this.selectedNodeList = [];\n\n      var calc = function calc(nodes) {\n        return nodes.every(function (node) {\n          if (isInArray(node.key, keys)) {\n            node.isSelected = true;\n\n            _this11.setSelectedNodeList(node);\n\n            if (!isMulti) {\n              // if not support multi select\n              return false;\n            }\n          } else {\n            node.isSelected = false;\n          }\n\n          if (node.children.length > 0) {\n            // Recursion\n            return calc(node.children);\n          }\n\n          return true;\n        });\n      };\n\n      calc(this.rootNodes);\n    }\n    /**\n     * Expand parent nodes by child node\n     * @param node\n     */\n\n  }, {\n    key: \"expandNodeAllParentBySearch\",\n    value: function expandNodeAllParentBySearch(node) {\n      var _this12 = this;\n\n      var calc = function calc(n) {\n        if (n) {\n          n.canHide = false;\n          n.setExpanded(true);\n\n          _this12.setExpandedNodeList(n);\n\n          if (n.getParentNode()) {\n            return calc(n.getParentNode());\n          }\n        }\n      };\n\n      calc(node.getParentNode());\n    }\n  }]);\n\n  return NzTreeBaseService;\n}();\n\nNzTreeBaseService.Éµfac = function NzTreeBaseService_Factory(t) {\n  return new (t || NzTreeBaseService)();\n};\n\nNzTreeBaseService.Éµprov = Éµngcc0.ÉµÉµdefineInjectable({\n  token: NzTreeBaseService,\n  factory: NzTreeBaseService.Éµfac\n});\n/*@__PURE__*/\n\n(function () {\n  Éµngcc0.ÉµsetClassMetadata(NzTreeBaseService, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nvar NzTreeHigherOrderServiceToken = new InjectionToken('NzTreeHigherOrder');\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nvar NzTreeBase = /*#__PURE__*/function () {\n  function NzTreeBase(nzTreeService) {\n    _classCallCheck(this, NzTreeBase);\n\n    this.nzTreeService = nzTreeService;\n  }\n  /**\n   * Coerces a value({@link any[]}) to a TreeNodes({@link NzTreeNode[]})\n   */\n\n\n  _createClass(NzTreeBase, [{\n    key: \"coerceTreeNodes\",\n    value: function coerceTreeNodes(value) {\n      var _this13 = this;\n\n      var nodes = [];\n\n      if (!this.nzTreeService.isArrayOfNzTreeNode(value)) {\n        // has not been new NzTreeNode\n        nodes = value.map(function (item) {\n          return new NzTreeNode(item, null, _this13.nzTreeService);\n        });\n      } else {\n        nodes = value.map(function (item) {\n          item.service = _this13.nzTreeService;\n          return item;\n        });\n      }\n\n      return nodes;\n    }\n    /**\n     * Get all nodes({@link NzTreeNode})\n     */\n\n  }, {\n    key: \"getTreeNodes\",\n    value: function getTreeNodes() {\n      return this.nzTreeService.rootNodes;\n    }\n    /**\n     * Get {@link NzTreeNode} with key\n     */\n\n  }, {\n    key: \"getTreeNodeByKey\",\n    value: function getTreeNodeByKey(key) {\n      // flat tree nodes\n      var nodes = [];\n\n      var getNode = function getNode(node) {\n        nodes.push(node);\n        node.getChildren().forEach(function (n) {\n          getNode(n);\n        });\n      };\n\n      this.getTreeNodes().forEach(function (n) {\n        getNode(n);\n      });\n      return nodes.find(function (n) {\n        return n.key === key;\n      }) || null;\n    }\n    /**\n     * Get checked nodes(merged)\n     */\n\n  }, {\n    key: \"getCheckedNodeList\",\n    value: function getCheckedNodeList() {\n      return this.nzTreeService.getCheckedNodeList();\n    }\n    /**\n     * Get selected nodes\n     */\n\n  }, {\n    key: \"getSelectedNodeList\",\n    value: function getSelectedNodeList() {\n      return this.nzTreeService.getSelectedNodeList();\n    }\n    /**\n     * Get half checked nodes\n     */\n\n  }, {\n    key: \"getHalfCheckedNodeList\",\n    value: function getHalfCheckedNodeList() {\n      return this.nzTreeService.getHalfCheckedNodeList();\n    }\n    /**\n     * Get expanded nodes\n     */\n\n  }, {\n    key: \"getExpandedNodeList\",\n    value: function getExpandedNodeList() {\n      return this.nzTreeService.getExpandedNodeList();\n    }\n    /**\n     * Get matched nodes(if nzSearchValue is not null)\n     */\n\n  }, {\n    key: \"getMatchedNodeList\",\n    value: function getMatchedNodeList() {\n      return this.nzTreeService.getMatchedNodeList();\n    }\n  }]);\n\n  return NzTreeBase;\n}();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzTreeBase, NzTreeBaseService, NzTreeHigherOrderServiceToken, NzTreeNode, _flattenTreeData as flattenTreeData, getKey, getPosition, isCheckDisabled, isInArray };","map":{"version":3,"sources":["../../components/core/tree/nz-tree-base-node.ts","../../components/core/tree/nz-tree-base.definitions.ts","../../components/core/tree/nz-tree-base-util.ts","../../components/core/tree/nz-tree-base.service.ts","../../components/core/tree/nz-tree-service.resolver.ts","../../components/core/tree/nz-tree-base.ts","../../components/core/tree/public-api.ts","../../components/core/tree/ng-zorro-antd-core-tree.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { NzTreeNodeBaseComponent } from './nz-tree-base.definitions';\nimport { NzTreeBaseService } from './nz-tree-base.service';\n\nexport type NzTreeNodeKey = string | number;\n\nexport interface FlattenNode {\n  parent: FlattenNode | null;\n  children: FlattenNode[];\n  pos: string;\n  data: NzTreeNode;\n  isStart: boolean[];\n  isEnd: boolean[];\n}\n\nexport interface NzTreeNodeOptions {\n  title: string;\n  key: string;\n  icon?: string;\n  isLeaf?: boolean;\n  checked?: boolean;\n  selected?: boolean;\n  selectable?: boolean;\n  disabled?: boolean;\n  disableCheckbox?: boolean;\n  expanded?: boolean;\n  children?: NzTreeNodeOptions[];\n\n  [key: string]: NzSafeAny;\n}\n\nexport class NzTreeNode {\n  private _title: string = '';\n  key!: string;\n  level: number = 0;\n  origin!: NzTreeNodeOptions;\n  // Parent Node\n  parentNode: NzTreeNode | null = null;\n  private _icon: string = '';\n  private _children: NzTreeNode[] = [];\n  private _isLeaf: boolean = false;\n  private _isChecked: boolean = false;\n  private _isSelectable: boolean = false;\n  private _isDisabled: boolean = false;\n  private _isDisableCheckbox: boolean = false;\n  private _isExpanded: boolean = false;\n  private _isHalfChecked: boolean = false;\n  private _isSelected: boolean = false;\n  private _isLoading: boolean = false;\n  canHide: boolean = false;\n  isMatched: boolean = false;\n\n  service: NzTreeBaseService | null = null;\n  component!: NzTreeNodeBaseComponent;\n\n  /** New added in Tree for easy data access */\n  isStart?: boolean[];\n  isEnd?: boolean[];\n\n  get treeService(): NzTreeBaseService | null {\n    return this.service || (this.parentNode && this.parentNode.treeService);\n  }\n\n  /**\n   * Init nzTreeNode\n   * @param option: user's input\n   * @param parent\n   * @param service: base nzTreeService\n   */\n  constructor(option: NzTreeNodeOptions | NzTreeNode, parent: NzTreeNode | null = null, service: NzTreeBaseService | null = null) {\n    if (option instanceof NzTreeNode) {\n      return option;\n    }\n    this.service = service || null;\n    this.origin = option;\n    this.key = option.key;\n    this.parentNode = parent;\n    this._title = option.title || '---';\n    this._icon = option.icon || '';\n    this._isLeaf = option.isLeaf || false;\n    this._children = [];\n    // option params\n    this._isChecked = option.checked || false;\n    this._isSelectable = option.disabled || option.selectable !== false;\n    this._isDisabled = option.disabled || false;\n    this._isDisableCheckbox = option.disableCheckbox || false;\n    this._isExpanded = option.isLeaf ? false : option.expanded || false;\n    this._isHalfChecked = false;\n    this._isSelected = (!option.disabled && option.selected) || false;\n    this._isLoading = false;\n    this.isMatched = false;\n\n    /**\n     * parent's checked status will affect children while initializing\n     */\n    if (parent) {\n      this.level = parent.level + 1;\n    } else {\n      this.level = 0;\n    }\n    if (typeof option.children !== 'undefined' && option.children !== null) {\n      option.children.forEach(nodeOptions => {\n        const s = this.treeService;\n        if (s && !s.isCheckStrictly && option.checked && !option.disabled && !nodeOptions.disabled && !nodeOptions.disableCheckbox) {\n          nodeOptions.checked = option.checked;\n        }\n        this._children.push(new NzTreeNode(nodeOptions, this));\n      });\n    }\n  }\n\n  /**\n   * auto generate\n   * get\n   * set\n   */\n  get title(): string {\n    return this._title;\n  }\n\n  set title(value: string) {\n    this._title = value;\n    this.update();\n  }\n\n  get icon(): string {\n    return this._icon;\n  }\n\n  set icon(value: string) {\n    this._icon = value;\n    this.update();\n  }\n\n  get children(): NzTreeNode[] {\n    return this._children;\n  }\n\n  set children(value: NzTreeNode[]) {\n    this._children = value;\n    this.update();\n  }\n\n  get isLeaf(): boolean {\n    return this._isLeaf;\n  }\n\n  set isLeaf(value: boolean) {\n    this._isLeaf = value;\n    this.update();\n  }\n\n  get isChecked(): boolean {\n    return this._isChecked;\n  }\n\n  set isChecked(value: boolean) {\n    this._isChecked = value;\n    this.origin.checked = value;\n    this.afterValueChange('isChecked');\n  }\n\n  get isHalfChecked(): boolean {\n    return this._isHalfChecked;\n  }\n\n  set isHalfChecked(value: boolean) {\n    this._isHalfChecked = value;\n    this.afterValueChange('isHalfChecked');\n  }\n\n  get isSelectable(): boolean {\n    return this._isSelectable;\n  }\n\n  set isSelectable(value: boolean) {\n    this._isSelectable = value;\n    this.update();\n  }\n\n  get isDisabled(): boolean {\n    return this._isDisabled;\n  }\n\n  set isDisabled(value: boolean) {\n    this._isDisabled = value;\n    this.update();\n  }\n\n  get isDisableCheckbox(): boolean {\n    return this._isDisableCheckbox;\n  }\n\n  set isDisableCheckbox(value: boolean) {\n    this._isDisableCheckbox = value;\n    this.update();\n  }\n\n  get isExpanded(): boolean {\n    return this._isExpanded;\n  }\n\n  set isExpanded(value: boolean) {\n    this._isExpanded = value;\n    this.origin.expanded = value;\n    this.afterValueChange('isExpanded');\n    this.afterValueChange('reRender');\n  }\n\n  get isSelected(): boolean {\n    return this._isSelected;\n  }\n\n  set isSelected(value: boolean) {\n    this._isSelected = value;\n    this.origin.selected = value;\n    this.afterValueChange('isSelected');\n  }\n\n  get isLoading(): boolean {\n    return this._isLoading;\n  }\n\n  set isLoading(value: boolean) {\n    this._isLoading = value;\n    this.update();\n  }\n\n  public setSyncChecked(checked: boolean = false, halfChecked: boolean = false): void {\n    this.setChecked(checked, halfChecked);\n    if (this.treeService && !this.treeService.isCheckStrictly) {\n      this.treeService.conduct(this);\n    }\n  }\n\n  public setChecked(checked: boolean = false, halfChecked: boolean = false): void {\n    this.origin.checked = checked;\n    this.isChecked = checked;\n    this.isHalfChecked = halfChecked;\n  }\n\n  public setExpanded(value: boolean): void {\n    this._isExpanded = value;\n    this.origin.expanded = value;\n    this.afterValueChange('isExpanded');\n  }\n\n  public getParentNode(): NzTreeNode | null {\n    return this.parentNode;\n  }\n\n  public getChildren(): NzTreeNode[] {\n    return this.children;\n  }\n\n  /**\n   * Support appending child nodes by position. Leaf node cannot be appended.\n   */\n  public addChildren(children: NzSafeAny[], childPos: number = -1): void {\n    if (!this.isLeaf) {\n      children.forEach(node => {\n        const refreshLevel = (n: NzTreeNode) => {\n          n.getChildren().forEach(c => {\n            c.level = c.getParentNode()!.level + 1;\n            // flush origin\n            c.origin.level = c.level;\n            refreshLevel(c);\n          });\n        };\n        let child = node;\n        if (child instanceof NzTreeNode) {\n          child.parentNode = this;\n        } else {\n          child = new NzTreeNode(node, this);\n        }\n        child.level = this.level + 1;\n        child.origin.level = child.level;\n        refreshLevel(child);\n        try {\n          childPos === -1 ? this.children.push(child) : this.children.splice(childPos, 0, child);\n          // flush origin\n        } catch (e) {}\n      });\n      this.origin.children = this.getChildren().map(v => v.origin);\n      // remove loading state\n      this.isLoading = false;\n    }\n    this.afterValueChange('addChildren');\n    this.afterValueChange('reRender');\n  }\n\n  public clearChildren(): void {\n    // refresh checked state\n    this.afterValueChange('clearChildren');\n    this.children = [];\n    this.origin.children = [];\n    this.afterValueChange('reRender');\n  }\n\n  public remove(): void {\n    const parentNode = this.getParentNode();\n    if (parentNode) {\n      parentNode.children = parentNode.getChildren().filter(v => v.key !== this.key);\n      parentNode.origin.children = parentNode.origin.children!.filter(v => v.key !== this.key);\n      this.afterValueChange('remove');\n      this.afterValueChange('reRender');\n    }\n  }\n\n  public afterValueChange(key: string): void {\n    if (this.treeService) {\n      switch (key) {\n        case 'isChecked':\n          this.treeService.setCheckedNodeList(this);\n          break;\n        case 'isHalfChecked':\n          this.treeService.setHalfCheckedNodeList(this);\n          break;\n        case 'isExpanded':\n          this.treeService.setExpandedNodeList(this);\n          break;\n        case 'isSelected':\n          this.treeService.setNodeActive(this);\n          break;\n        case 'clearChildren':\n          this.treeService.afterRemove(this.getChildren());\n          break;\n        case 'remove':\n          this.treeService.afterRemove([this]);\n          break;\n        case 'reRender':\n          this.treeService.flattenTreeData(\n            this.treeService.rootNodes,\n            this.treeService.getExpandedNodeList().map(v => v.key!)\n          );\n          break;\n      }\n    }\n    this.update();\n  }\n\n  public update(): void {\n    if (this.component) {\n      this.component.markForCheck();\n    }\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { NzTreeNode } from './nz-tree-base-node';\n\nexport interface NzFormatEmitEvent {\n  eventName: string;\n  node?: NzTreeNode | null;\n  event?: MouseEvent | DragEvent | null;\n  dragNode?: NzTreeNode;\n  selectedKeys?: NzTreeNode[];\n  checkedKeys?: NzTreeNode[];\n  matchedKeys?: NzTreeNode[];\n  nodes?: NzTreeNode[];\n  keys?: string[];\n}\n\nexport interface NzFormatBeforeDropEvent {\n  dragNode: NzTreeNode;\n  node: NzTreeNode;\n  pos: number;\n}\n\nexport interface NzTreeNodeBaseComponent {\n  markForCheck(): void;\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { FlattenNode, NzTreeNode, NzTreeNodeKey } from './nz-tree-base-node';\n\nexport function isCheckDisabled(node: NzTreeNode): boolean {\n  const { isDisabled, isDisableCheckbox } = node;\n  return !!(isDisabled || isDisableCheckbox);\n}\n\nexport function isInArray(needle: NzSafeAny, haystack: NzSafeAny[]): boolean {\n  return haystack.length > 0 && haystack.indexOf(needle) > -1;\n}\n\nexport function getPosition(level: string | number, index: number): string {\n  return `${level}-${index}`;\n}\n\nexport function getKey(key: NzTreeNodeKey, pos: string): NzTreeNodeKey {\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n  return pos;\n}\n\n/**\n * Flat nest tree data into flatten list. This is used for virtual list render.\n * @param treeNodeList Origin data node list\n * @param expandedKeys\n * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).\n */\nexport function flattenTreeData(treeNodeList: NzTreeNode[] = [], expandedKeys: NzTreeNodeKey[] | true = []): FlattenNode[] {\n  const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);\n  const flattenList: FlattenNode[] = [];\n\n  function dig(list: NzTreeNode[], parent: FlattenNode | null = null): FlattenNode[] {\n    return list.map((treeNode, index) => {\n      const pos: string = getPosition(parent ? parent.pos : '0', index);\n      const mergedKey = getKey(treeNode.key, pos);\n      treeNode.isStart = [...(parent ? parent.isStart : []), index === 0];\n      treeNode.isEnd = [...(parent ? parent.isEnd : []), index === list.length - 1];\n      // Add FlattenDataNode into list\n      // TODO: only need data here.\n      const flattenNode: FlattenNode = {\n        parent,\n        pos,\n        children: [],\n        data: treeNode,\n        isStart: [...(parent ? parent.isStart : []), index === 0],\n        isEnd: [...(parent ? parent.isEnd : []), index === list.length - 1]\n      };\n\n      flattenList.push(flattenNode);\n\n      // Loop treeNode children\n      if (expandedKeys === true || expandedKeySet.has(mergedKey) || treeNode.isExpanded) {\n        flattenNode.children = dig(treeNode.children || [], flattenNode);\n      } else {\n        flattenNode.children = [];\n      }\n\n      return flattenNode;\n    });\n  }\n\n  dig(treeNodeList);\n  return flattenList;\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { Injectable } from '@angular/core';\n\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { BehaviorSubject } from 'rxjs';\nimport { NzTreeNode, NzTreeNodeKey } from './nz-tree-base-node';\nimport { flattenTreeData, isCheckDisabled, isInArray } from './nz-tree-base-util';\nimport { NzFormatEmitEvent } from './nz-tree-base.definitions';\n\n@Injectable()\nexport class NzTreeBaseService {\n  DRAG_SIDE_RANGE = 0.25;\n  DRAG_MIN_GAP = 2;\n\n  isCheckStrictly: boolean = false;\n  isMultiple: boolean = false;\n  selectedNode!: NzTreeNode;\n  rootNodes: NzTreeNode[] = [];\n  flattenNodes$ = new BehaviorSubject<NzTreeNode[]>([]);\n  selectedNodeList: NzTreeNode[] = [];\n  expandedNodeList: NzTreeNode[] = [];\n  checkedNodeList: NzTreeNode[] = [];\n  halfCheckedNodeList: NzTreeNode[] = [];\n  matchedNodeList: NzTreeNode[] = [];\n\n  /**\n   * reset tree nodes will clear default node list\n   */\n  initTree(nzNodes: NzTreeNode[]): void {\n    this.rootNodes = nzNodes;\n    this.expandedNodeList = [];\n    this.selectedNodeList = [];\n    this.halfCheckedNodeList = [];\n    this.checkedNodeList = [];\n    this.matchedNodeList = [];\n  }\n\n  flattenTreeData(nzNodes: NzTreeNode[], expandedKeys: NzTreeNodeKey[] | true = []): void {\n    this.flattenNodes$.next(flattenTreeData(nzNodes, expandedKeys).map(item => item.data));\n  }\n\n  getSelectedNode(): NzTreeNode | null {\n    return this.selectedNode;\n  }\n\n  /**\n   * get some list\n   */\n  getSelectedNodeList(): NzTreeNode[] {\n    return this.conductNodeState('select');\n  }\n\n  /**\n   * return checked nodes\n   */\n  getCheckedNodeList(): NzTreeNode[] {\n    return this.conductNodeState('check');\n  }\n\n  getHalfCheckedNodeList(): NzTreeNode[] {\n    return this.conductNodeState('halfCheck');\n  }\n\n  /**\n   * return expanded nodes\n   */\n  getExpandedNodeList(): NzTreeNode[] {\n    return this.conductNodeState('expand');\n  }\n\n  /**\n   * return search matched nodes\n   */\n  getMatchedNodeList(): NzTreeNode[] {\n    return this.conductNodeState('match');\n  }\n\n  isArrayOfNzTreeNode(value: NzSafeAny[]): boolean {\n    return value.every(item => item instanceof NzTreeNode);\n  }\n\n  /**\n   * set drag node\n   */\n  setSelectedNode(node: NzTreeNode): void {\n    this.selectedNode = node;\n  }\n\n  /**\n   * set node selected status\n   */\n  setNodeActive(node: NzTreeNode): void {\n    if (!this.isMultiple && node.isSelected) {\n      this.selectedNodeList.forEach(n => {\n        if (node.key !== n.key) {\n          // reset other nodes\n          n.isSelected = false;\n        }\n      });\n      // single mode: remove pre node\n      this.selectedNodeList = [];\n    }\n    this.setSelectedNodeList(node, this.isMultiple);\n  }\n\n  /**\n   * add or remove node to selectedNodeList\n   */\n  setSelectedNodeList(node: NzTreeNode, isMultiple: boolean = false): void {\n    const index = this.getIndexOfArray(this.selectedNodeList, node.key);\n    if (isMultiple) {\n      if (node.isSelected && index === -1) {\n        this.selectedNodeList.push(node);\n      }\n    } else {\n      if (node.isSelected && index === -1) {\n        this.selectedNodeList = [node];\n      }\n    }\n    if (!node.isSelected) {\n      this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key);\n    }\n  }\n\n  /**\n   * merge checked nodes\n   */\n  setHalfCheckedNodeList(node: NzTreeNode): void {\n    const index = this.getIndexOfArray(this.halfCheckedNodeList, node.key);\n    if (node.isHalfChecked && index === -1) {\n      this.halfCheckedNodeList.push(node);\n    } else if (!node.isHalfChecked && index > -1) {\n      this.halfCheckedNodeList = this.halfCheckedNodeList.filter(n => node.key !== n.key);\n    }\n  }\n\n  setCheckedNodeList(node: NzTreeNode): void {\n    const index = this.getIndexOfArray(this.checkedNodeList, node.key);\n    if (node.isChecked && index === -1) {\n      this.checkedNodeList.push(node);\n    } else if (!node.isChecked && index > -1) {\n      this.checkedNodeList = this.checkedNodeList.filter(n => node.key !== n.key);\n    }\n  }\n\n  /**\n   * conduct checked/selected/expanded keys\n   */\n  conductNodeState(type: string = 'check'): NzTreeNode[] {\n    let resultNodesList: NzTreeNode[] = [];\n    switch (type) {\n      case 'select':\n        resultNodesList = this.selectedNodeList;\n        break;\n      case 'expand':\n        resultNodesList = this.expandedNodeList;\n        break;\n      case 'match':\n        resultNodesList = this.matchedNodeList;\n        break;\n      case 'check':\n        resultNodesList = this.checkedNodeList;\n        const isIgnore = (node: NzTreeNode): boolean => {\n          const parentNode = node.getParentNode();\n          if (parentNode) {\n            if (this.checkedNodeList.findIndex(n => n.key === parentNode.key) > -1) {\n              return true;\n            } else {\n              return isIgnore(parentNode);\n            }\n          }\n          return false;\n        };\n        // merge checked\n        if (!this.isCheckStrictly) {\n          resultNodesList = this.checkedNodeList.filter(n => !isIgnore(n));\n        }\n        break;\n      case 'halfCheck':\n        if (!this.isCheckStrictly) {\n          resultNodesList = this.halfCheckedNodeList;\n        }\n        break;\n    }\n    return resultNodesList;\n  }\n\n  /**\n   * set expanded nodes\n   */\n  setExpandedNodeList(node: NzTreeNode): void {\n    if (node.isLeaf) {\n      return;\n    }\n    const index = this.getIndexOfArray(this.expandedNodeList, node.key);\n    if (node.isExpanded && index === -1) {\n      this.expandedNodeList.push(node);\n    } else if (!node.isExpanded && index > -1) {\n      this.expandedNodeList.splice(index, 1);\n    }\n  }\n\n  setMatchedNodeList(node: NzTreeNode): void {\n    const index = this.getIndexOfArray(this.matchedNodeList, node.key);\n    if (node.isMatched && index === -1) {\n      this.matchedNodeList.push(node);\n    } else if (!node.isMatched && index > -1) {\n      this.matchedNodeList.splice(index, 1);\n    }\n  }\n\n  /**\n   * check state\n   * @param isCheckStrictly\n   */\n  refreshCheckState(isCheckStrictly: boolean = false): void {\n    if (isCheckStrictly) {\n      return;\n    }\n    this.checkedNodeList.forEach(node => {\n      this.conduct(node, isCheckStrictly);\n    });\n  }\n\n  // reset other node checked state based current node\n  conduct(node: NzTreeNode, isCheckStrictly: boolean = false): void {\n    const isChecked = node.isChecked;\n    if (node && !isCheckStrictly) {\n      this.conductUp(node);\n      this.conductDown(node, isChecked);\n    }\n  }\n\n  /**\n   * 1ãchildren half checked\n   * 2ãchildren all checked, parent checked\n   * 3ãno children checked\n   */\n  conductUp(node: NzTreeNode): void {\n    const parentNode = node.getParentNode();\n    if (parentNode) {\n      if (!isCheckDisabled(parentNode)) {\n        if (parentNode.children.every(child => isCheckDisabled(child) || (!child.isHalfChecked && child.isChecked))) {\n          parentNode.isChecked = true;\n          parentNode.isHalfChecked = false;\n        } else if (parentNode.children.some(child => child.isHalfChecked || child.isChecked)) {\n          parentNode.isChecked = false;\n          parentNode.isHalfChecked = true;\n        } else {\n          parentNode.isChecked = false;\n          parentNode.isHalfChecked = false;\n        }\n      }\n      this.setCheckedNodeList(parentNode);\n      this.setHalfCheckedNodeList(parentNode);\n      this.conductUp(parentNode);\n    }\n  }\n\n  /**\n   * reset child check state\n   */\n  conductDown(node: NzTreeNode, value: boolean): void {\n    if (!isCheckDisabled(node)) {\n      node.isChecked = value;\n      node.isHalfChecked = false;\n      this.setCheckedNodeList(node);\n      this.setHalfCheckedNodeList(node);\n      node.children.forEach(n => {\n        this.conductDown(n, value);\n      });\n    }\n  }\n\n  /**\n   * flush after delete node\n   */\n  afterRemove(nodes: NzTreeNode[]): void {\n    // to reset selectedNodeList & expandedNodeList\n    const loopNode = (node: NzTreeNode) => {\n      // remove selected node\n      this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key);\n      // remove expanded node\n      this.expandedNodeList = this.expandedNodeList.filter(n => n.key !== node.key);\n      // remove checked node\n      this.checkedNodeList = this.checkedNodeList.filter(n => n.key !== node.key);\n      if (node.children) {\n        node.children.forEach(child => {\n          loopNode(child);\n        });\n      }\n    };\n    nodes.forEach(n => {\n      loopNode(n);\n    });\n    this.refreshCheckState(this.isCheckStrictly);\n  }\n\n  /**\n   * drag event\n   */\n  refreshDragNode(node: NzTreeNode): void {\n    if (node.children.length === 0) {\n      // until root\n      this.conductUp(node);\n    } else {\n      node.children.forEach(child => {\n        this.refreshDragNode(child);\n      });\n    }\n  }\n\n  // reset node level\n  resetNodeLevel(node: NzTreeNode): void {\n    const parentNode = node.getParentNode();\n    if (parentNode) {\n      node.level = parentNode.level + 1;\n    } else {\n      node.level = 0;\n    }\n    for (const child of node.children) {\n      this.resetNodeLevel(child);\n    }\n  }\n\n  calcDropPosition(event: DragEvent): number {\n    const { clientY } = event;\n    // to fix firefox undefined\n    const { top, bottom, height } = (event.target as Element).getBoundingClientRect();\n    const des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);\n\n    if (clientY <= top + des) {\n      return -1;\n    } else if (clientY >= bottom - des) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  /**\n   * drop\n   * 0: inner -1: pre 1: next\n   */\n  dropAndApply(targetNode: NzTreeNode, dragPos: number = -1): void {\n    if (!targetNode || dragPos > 1) {\n      return;\n    }\n    const treeService = targetNode.treeService;\n    const targetParent = targetNode.getParentNode();\n    const isSelectedRootNode = this.selectedNode.getParentNode();\n    // remove the dragNode\n    if (isSelectedRootNode) {\n      isSelectedRootNode.children = isSelectedRootNode.children.filter(n => n.key !== this.selectedNode.key);\n    } else {\n      this.rootNodes = this.rootNodes.filter(n => n.key !== this.selectedNode.key);\n    }\n    switch (dragPos) {\n      case 0:\n        targetNode.addChildren([this.selectedNode]);\n        this.resetNodeLevel(targetNode);\n        break;\n      case -1:\n      case 1:\n        const tIndex = dragPos === 1 ? 1 : 0;\n        if (targetParent) {\n          targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);\n          const parentNode = this.selectedNode.getParentNode();\n          if (parentNode) {\n            this.resetNodeLevel(parentNode);\n          }\n        } else {\n          const targetIndex = this.rootNodes.indexOf(targetNode) + tIndex;\n          // Insert root node.\n          this.rootNodes.splice(targetIndex, 0, this.selectedNode);\n          this.rootNodes[targetIndex].parentNode = null;\n          this.resetNodeLevel(this.rootNodes[targetIndex]);\n        }\n        break;\n    }\n    // flush all nodes\n    this.rootNodes.forEach(child => {\n      if (!child.treeService) {\n        child.service = treeService;\n      }\n      this.refreshDragNode(child);\n    });\n  }\n\n  /**\n   * emit Structure\n   * eventName\n   * node\n   * event: MouseEvent / DragEvent\n   * dragNode\n   */\n  formatEvent(eventName: string, node: NzTreeNode | null, event: MouseEvent | DragEvent | null): NzFormatEmitEvent {\n    const emitStructure: NzFormatEmitEvent = {\n      eventName: eventName,\n      node: node,\n      event: event\n    };\n    switch (eventName) {\n      case 'dragstart':\n      case 'dragenter':\n      case 'dragover':\n      case 'dragleave':\n      case 'drop':\n      case 'dragend':\n        Object.assign(emitStructure, { dragNode: this.getSelectedNode() });\n        break;\n      case 'click':\n      case 'dblclick':\n        Object.assign(emitStructure, { selectedKeys: this.selectedNodeList });\n        Object.assign(emitStructure, { nodes: this.selectedNodeList });\n        Object.assign(emitStructure, { keys: this.selectedNodeList.map(n => n.key) });\n        break;\n      case 'check':\n        const checkedNodeList = this.getCheckedNodeList();\n        Object.assign(emitStructure, { checkedKeys: checkedNodeList });\n        Object.assign(emitStructure, { nodes: checkedNodeList });\n        Object.assign(emitStructure, { keys: checkedNodeList.map(n => n.key) });\n        break;\n      case 'search':\n        Object.assign(emitStructure, { matchedKeys: this.getMatchedNodeList() });\n        Object.assign(emitStructure, { nodes: this.getMatchedNodeList() });\n        Object.assign(emitStructure, { keys: this.getMatchedNodeList().map(n => n.key) });\n        break;\n      case 'expand':\n        Object.assign(emitStructure, { nodes: this.expandedNodeList });\n        Object.assign(emitStructure, { keys: this.expandedNodeList.map(n => n.key) });\n        break;\n    }\n    return emitStructure;\n  }\n\n  /**\n   * New functions for flatten nodes\n   */\n\n  getIndexOfArray(list: NzTreeNode[], key: string): number {\n    return list.findIndex(v => v.key === key);\n  }\n\n  /**\n   * Render by nzCheckedKeys\n   * When keys equals null, just render with checkStrictly\n   * @param keys\n   * @param checkStrictly\n   */\n  conductCheck(keys: NzTreeNodeKey[] | null, checkStrictly: boolean): void {\n    this.checkedNodeList = [];\n    this.halfCheckedNodeList = [];\n    const calc = (nodes: NzTreeNode[]) => {\n      nodes.forEach(node => {\n        if (keys === null) {\n          // render tree if no default checked keys found\n          node.isChecked = !!node.origin.checked;\n        } else {\n          if (isInArray(node.key, keys || [])) {\n            node.isChecked = true;\n            node.isHalfChecked = false;\n          } else {\n            node.isChecked = false;\n            node.isHalfChecked = false;\n          }\n        }\n        if (node.children.length > 0) {\n          calc(node.children);\n        }\n      });\n    };\n    calc(this.rootNodes);\n    this.refreshCheckState(checkStrictly);\n  }\n\n  conductExpandedKeys(keys: NzTreeNodeKey[] | true = []): void {\n    const expandedKeySet = new Set(keys === true ? [] : keys);\n    this.expandedNodeList = [];\n    const calc = (nodes: NzTreeNode[]) => {\n      nodes.forEach(node => {\n        node.setExpanded(keys === true || expandedKeySet.has(node.key) || node.isExpanded === true);\n        if (node.isExpanded) {\n          this.setExpandedNodeList(node);\n        }\n        if (node.children.length > 0) {\n          calc(node.children);\n        }\n      });\n    };\n    calc(this.rootNodes);\n  }\n\n  conductSelectedKeys(keys: NzTreeNodeKey[], isMulti: boolean): void {\n    this.selectedNodeList.forEach(node => (node.isSelected = false));\n    this.selectedNodeList = [];\n    const calc = (nodes: NzTreeNode[]): boolean => {\n      return nodes.every(node => {\n        if (isInArray(node.key, keys)) {\n          node.isSelected = true;\n          this.setSelectedNodeList(node);\n          if (!isMulti) {\n            // if not support multi select\n            return false;\n          }\n        } else {\n          node.isSelected = false;\n        }\n        if (node.children.length > 0) {\n          // Recursion\n          return calc(node.children);\n        }\n        return true;\n      });\n    };\n    calc(this.rootNodes);\n  }\n\n  /**\n   * Expand parent nodes by child node\n   * @param node\n   */\n  expandNodeAllParentBySearch(node: NzTreeNode): void {\n    const calc = (n: NzTreeNode | null): void => {\n      if (n) {\n        n.canHide = false;\n        n.setExpanded(true);\n        this.setExpandedNodeList(n);\n        if (n.getParentNode()) {\n          return calc(n.getParentNode());\n        }\n      }\n    };\n    calc(node.getParentNode());\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { InjectionToken } from '@angular/core';\n\nimport { NzTreeBaseService } from './nz-tree-base.service';\n\nexport const NzTreeHigherOrderServiceToken = new InjectionToken<NzTreeBaseService>('NzTreeHigherOrder');\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { NzTreeNode } from './nz-tree-base-node';\nimport { NzTreeBaseService } from './nz-tree-base.service';\n\nexport class NzTreeBase {\n  constructor(public nzTreeService: NzTreeBaseService) {}\n\n  /**\n   * Coerces a value({@link any[]}) to a TreeNodes({@link NzTreeNode[]})\n   */\n  coerceTreeNodes(value: NzSafeAny[]): NzTreeNode[] {\n    let nodes: NzTreeNode[] = [];\n    if (!this.nzTreeService.isArrayOfNzTreeNode(value)) {\n      // has not been new NzTreeNode\n      nodes = value.map(item => new NzTreeNode(item, null, this.nzTreeService));\n    } else {\n      nodes = value.map((item: NzTreeNode) => {\n        item.service = this.nzTreeService;\n        return item;\n      });\n    }\n    return nodes;\n  }\n\n  /**\n   * Get all nodes({@link NzTreeNode})\n   */\n  getTreeNodes(): NzTreeNode[] {\n    return this.nzTreeService.rootNodes;\n  }\n\n  /**\n   * Get {@link NzTreeNode} with key\n   */\n  getTreeNodeByKey(key: string): NzTreeNode | null {\n    // flat tree nodes\n    const nodes: NzTreeNode[] = [];\n    const getNode = (node: NzTreeNode): void => {\n      nodes.push(node);\n      node.getChildren().forEach(n => {\n        getNode(n);\n      });\n    };\n    this.getTreeNodes().forEach(n => {\n      getNode(n);\n    });\n    return nodes.find(n => n.key === key) || null;\n  }\n\n  /**\n   * Get checked nodes(merged)\n   */\n  getCheckedNodeList(): NzTreeNode[] {\n    return this.nzTreeService.getCheckedNodeList();\n  }\n\n  /**\n   * Get selected nodes\n   */\n  getSelectedNodeList(): NzTreeNode[] {\n    return this.nzTreeService.getSelectedNodeList();\n  }\n\n  /**\n   * Get half checked nodes\n   */\n  getHalfCheckedNodeList(): NzTreeNode[] {\n    return this.nzTreeService.getHalfCheckedNodeList();\n  }\n\n  /**\n   * Get expanded nodes\n   */\n  getExpandedNodeList(): NzTreeNode[] {\n    return this.nzTreeService.getExpandedNodeList();\n  }\n\n  /**\n   * Get matched nodes(if nzSearchValue is not null)\n   */\n  getMatchedNodeList(): NzTreeNode[] {\n    return this.nzTreeService.getMatchedNodeList();\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nexport * from './nz-tree-base-node';\nexport * from './nz-tree-base.definitions';\nexport * from './nz-tree-base.service';\nexport * from './nz-tree-service.resolver';\nexport * from './nz-tree-base';\nexport * from './nz-tree-base-util';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"]},"metadata":{},"sourceType":"module"}