{"version":3,"file":"ngx-drag-drop.umd.min.js","sources":["~/ngx-drag-drop/src/dnd-utils.ts","~/ngx-drag-drop/src/dnd-state.ts","~/ngx-drag-drop/src/dnd-draggable.directive.ts","~/ngx-drag-drop/src/dnd-dropzone.directive.ts","~/ngx-drag-drop/src/dnd-handle.directive.ts","~/ngx-drag-drop/src/dnd.module.ts"],"sourcesContent":["import { DropEffect, EffectAllowed } from './dnd-types';\n\nexport interface DragDropData {\n  data?:any;\n  type?:string;\n}\n\nexport interface DndEvent extends DragEvent {\n  _dndUsingHandle?:boolean;\n  _dndDropzoneActive?:true;\n}\n\nexport type DndDragImageOffsetFunction = ( event:DragEvent, dragImage:Element ) => { x:number, y:number };\n\nexport const /** @type {?} */ DROP_EFFECTS = /** @type {?} */(( [ \"move\", \"copy\", \"link\" ] as DropEffect[]));\n\nexport const /** @type {?} */ CUSTOM_MIME_TYPE = \"application/x-dnd\";\nexport const /** @type {?} */ JSON_MIME_TYPE = \"application/json\";\nexport const /** @type {?} */ MSIE_MIME_TYPE = \"Text\";\n/**\n * @param {?} mimeType\n * @return {?}\n */\nfunction mimeTypeIsCustom( mimeType:string ) {\n\n  return mimeType.substr( 0, CUSTOM_MIME_TYPE.length ) === CUSTOM_MIME_TYPE;\n}\n/**\n * @param {?} event\n * @return {?}\n */\nexport function getWellKnownMimeType( event:DragEvent ):string | null {\n\n  const /** @type {?} */ types = event.dataTransfer.types;\n\n  // IE 9 workaround.\n  if( !types ) {\n\n    return MSIE_MIME_TYPE;\n  }\n\n  for( let /** @type {?} */ i = 0; i < types.length; i++ ) {\n\n    if( types[ i ] === MSIE_MIME_TYPE\n      || types[ i ] === JSON_MIME_TYPE\n      || mimeTypeIsCustom( types[ i ] ) ) {\n\n      return types[ i ];\n    }\n  }\n\n  return null;\n}\n/**\n * @param {?} event\n * @param {?} data\n * @param {?} effectAllowed\n * @return {?}\n */\nexport function setDragData( event:DragEvent, data:DragDropData, effectAllowed:EffectAllowed ):void {\n\n  // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n  // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n  const /** @type {?} */ mimeType = CUSTOM_MIME_TYPE + (data.type ? (\"-\" + data.type) : \"\");\n\n  const /** @type {?} */ dataString = JSON.stringify( data );\n\n  try {\n\n    event.dataTransfer.setData( mimeType, dataString );\n\n  }\n  catch( /** @type {?} */ e ) {\n\n    //   Setting a custom MIME type did not work, we are probably in IE or Edge.\n    try {\n\n      event.dataTransfer.setData( JSON_MIME_TYPE, dataString );\n\n    }\n    catch( /** @type {?} */ e ) {\n\n      //   We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n      //   does not allow changing the cursor in the dragover event, therefore we have to choose\n      //   the one we want to display now by setting effectAllowed.\n      const /** @type {?} */ effectsAllowed = filterEffects( DROP_EFFECTS, effectAllowed );\n      event.dataTransfer.effectAllowed = effectsAllowed[ 0 ];\n\n      event.dataTransfer.setData( MSIE_MIME_TYPE, dataString );\n    }\n  }\n}\n/**\n * @param {?} event\n * @param {?} dragIsExternal\n * @return {?}\n */\nexport function getDropData( event:DragEvent, dragIsExternal:boolean ):DragDropData {\n\n  // check if the mime type is well known\n  const /** @type {?} */ mimeType = getWellKnownMimeType( event );\n\n  // drag did not originate from [dndDraggable]\n  if( dragIsExternal === true ) {\n\n    if( mimeType !== null\n      && mimeTypeIsCustom( mimeType ) ) {\n\n      // the type of content is well known and safe to handle\n      return JSON.parse( event.dataTransfer.getData( mimeType ) );\n    }\n\n    // the contained data is unknown, let user handle it\n    return {};\n  }\n\n  // the type of content is well known and safe to handle\n  return JSON.parse( event.dataTransfer.getData( mimeType ) );\n}\n/**\n * @param {?} effects\n * @param {?} allowed\n * @return {?}\n */\nexport function filterEffects( effects:DropEffect[], allowed:EffectAllowed | DropEffect ):DropEffect[] {\n\n  if( allowed === \"all\" ) {\n\n    return effects;\n  }\n\n  return effects.filter( function( effect ) {\n\n    return allowed.toLowerCase().indexOf( effect ) !== -1;\n  } );\n}\n/**\n * @param {?} parentElement\n * @param {?} childElement\n * @return {?}\n */\nexport function getDirectChildElement( parentElement:Element, childElement:Element ):Element | null {\n\n  let /** @type {?} */ directChild:Node = childElement;\n\n  while( directChild.parentNode !== parentElement ) {\n\n    // reached root node without finding given parent\n    if( !directChild.parentNode ) {\n\n      return null;\n    }\n\n    directChild = directChild.parentNode;\n  }\n\n  return /** @type {?} */(( directChild as Element));\n}\n/**\n * @param {?} event\n * @param {?} element\n * @param {?} horizontal\n * @return {?}\n */\nexport function shouldPositionPlaceholderBeforeElement( event:DragEvent, element:Element, horizontal:boolean ) {\n\n  const /** @type {?} */ bounds = element.getBoundingClientRect();\n\n  // If the pointer is in the upper half of the list item element,\n  // we position the placeholder before the list item, otherwise after it.\n  if( horizontal ) {\n\n    return (event.clientX < bounds.left + bounds.width / 2);\n  }\n\n  return (event.clientY < bounds.top + bounds.height / 2);\n}\n/**\n * @param {?} event\n * @param {?} dragImage\n * @return {?}\n */\nexport function calculateDragImageOffset( event:DragEvent, dragImage:Element ):{ x:number, y:number } {\n\n  const /** @type {?} */ dragImageComputedStyle = window.getComputedStyle( dragImage );\n  const /** @type {?} */ paddingTop = parseFloat( dragImageComputedStyle.paddingTop ) || 0;\n  const /** @type {?} */ paddingLeft = parseFloat( dragImageComputedStyle.paddingLeft ) || 0;\n  const /** @type {?} */ borderTop = parseFloat( dragImageComputedStyle.borderTopWidth ) || 0;\n  const /** @type {?} */ borderLeft = parseFloat( dragImageComputedStyle.borderLeftWidth ) || 0;\n\n  return {\n    x: event.offsetX + paddingLeft + borderLeft,\n    y: event.offsetY + paddingTop + borderTop\n  };\n}\n/**\n * @param {?} event\n * @param {?} dragImage\n * @param {?} offsetFunction\n * @return {?}\n */\nexport function setDragImage( event:DragEvent, dragImage:Element, offsetFunction:DndDragImageOffsetFunction ):void {\n\n  const /** @type {?} */ offset = offsetFunction( event, dragImage ) || {x: 0, y: 0};\n\n  ( /** @type {?} */((event.dataTransfer as any))).setDragImage( dragImage, offset.x, offset.y );\n}\n","import {\n  CUSTOM_MIME_TYPE,\n  DROP_EFFECTS,\n  filterEffects,\n  getWellKnownMimeType,\n  JSON_MIME_TYPE,\n  MSIE_MIME_TYPE\n} from './dnd-utils';\nimport { DropEffect, EffectAllowed } from './dnd-types';\n\nexport interface DndState {\n  isDragging:boolean;\n  dropEffect?:DropEffect;\n  effectAllowed?:EffectAllowed;\n  type?:string;\n}\n\nconst /** @type {?} */ _dndState:DndState = {\n  isDragging: false,\n  dropEffect: \"none\",\n  effectAllowed: \"all\",\n  type: undefined\n};\n/**\n * @param {?} event\n * @param {?} effectAllowed\n * @param {?} type\n * @return {?}\n */\nexport function startDrag( event:DragEvent, effectAllowed:EffectAllowed, type:string | undefined ) {\n\n  _dndState.isDragging = true;\n  _dndState.dropEffect = \"none\";\n  _dndState.effectAllowed = effectAllowed;\n  _dndState.type = type;\n\n  event.dataTransfer.effectAllowed = effectAllowed;\n}\n/**\n * @return {?}\n */\nexport function endDrag() {\n\n  _dndState.isDragging = false;\n  _dndState.dropEffect = undefined;\n  _dndState.effectAllowed = undefined;\n  _dndState.type = undefined;\n}\n/**\n * @param {?} event\n * @param {?} dropEffect\n * @return {?}\n */\nexport function setDropEffect( event:DragEvent, dropEffect:DropEffect ) {\n\n  if( _dndState.isDragging === true ) {\n\n    _dndState.dropEffect = dropEffect;\n  }\n\n  event.dataTransfer.dropEffect = dropEffect;\n}\n/**\n * @param {?} event\n * @param {?=} effectAllowed\n * @return {?}\n */\nexport function getDropEffect( event:DragEvent, effectAllowed?:EffectAllowed | DropEffect ):DropEffect {\n\n  let /** @type {?} */ effects = DROP_EFFECTS;\n\n  effects = filterEffects( effects, /** @type {?} */(( event.dataTransfer.effectAllowed as EffectAllowed)) );\n\n  if( _dndState.isDragging === true ) {\n\n    effects = filterEffects( effects, _dndState.effectAllowed );\n  }\n\n  if( effectAllowed ) {\n\n    effects = filterEffects( effects, effectAllowed );\n  }\n\n  // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n  // therefore the following modifier keys will only affect other operating systems.\n  if( effects.length === 0 ) {\n\n    return \"none\";\n  }\n\n  if( event.ctrlKey && effects.indexOf( \"copy\" ) !== -1 ) {\n\n    return \"copy\";\n  }\n\n  if( event.altKey && effects.indexOf( \"link\" ) !== -1 ) {\n\n    return \"link\";\n  }\n\n  return /** @type {?} */(( effects[ 0 ] as DropEffect));\n}\n/**\n * @param {?} event\n * @return {?}\n */\nexport function getDndType( event:DragEvent ):string | undefined {\n\n  if( _dndState.isDragging === true ) {\n\n    return _dndState.type;\n  }\n\n  const /** @type {?} */ mimeType = getWellKnownMimeType( event );\n\n  if( mimeType === null ) {\n\n    return undefined;\n  }\n\n  if( mimeType === MSIE_MIME_TYPE\n    || mimeType === JSON_MIME_TYPE ) {\n\n    return undefined;\n  }\n\n  return mimeType.substr( CUSTOM_MIME_TYPE.length + 1 ) || undefined;\n}\n/**\n * @return {?}\n */\nexport function isExternalDrag():boolean {\n\n  return _dndState.isDragging === false;\n}\n\nexport const /** @type {?} */ dndState:Readonly<DndState> = /** @type {?} */(( _dndState as Readonly<DndState>));\n","import {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostBinding,\n  HostListener,\n  Input,\n  OnDestroy,\n  Output,\n  Renderer2\n} from '@angular/core';\nimport { calculateDragImageOffset, DndDragImageOffsetFunction, DndEvent, setDragData, setDragImage } from './dnd-utils';\nimport { DndHandleDirective } from './dnd-handle.directive';\nimport { dndState, endDrag, startDrag } from './dnd-state';\nimport { EffectAllowed } from './dnd-types';\nexport class DndDragImageRefDirective {\n/**\n * @param {?} parent\n * @param {?} elementRef\n */\nconstructor( parent:DndDraggableDirective,\n               elementRef:ElementRef ) {\n\n    parent.registerDragImage( elementRef );\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: \"[dndDragImageRef]\"\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: DndDraggableDirective, },\n{type: ElementRef, },\n];\n}\n\nfunction DndDragImageRefDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nDndDragImageRefDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDndDragImageRefDirective.ctorParameters;\n}\n\nexport class DndDraggableDirective implements OnDestroy {\n\n  \n  dndDraggable:any;\n\n  \n  dndEffectAllowed:EffectAllowed = \"copy\";\n\n  \n  dndType?:string;\n\n  \n  dndDraggingClass = \"dndDragging\";\n\n  \n  dndDraggingSourceClass = \"dndDraggingSource\";\n\n  \n  dndDraggableDisabledClass = \"dndDraggableDisabled\";\n\n  \n  dndDragImageOffsetFunction:DndDragImageOffsetFunction = calculateDragImageOffset;\n\n  \n  readonly dndStart:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  \n  readonly dndEnd:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  \n  readonly dndMoved:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  \n  readonly dndCopied:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  \n  readonly dndLinked:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  \n  readonly dndCanceled:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  \n  draggable = true;\nprivate dndHandle?:DndHandleDirective;\nprivate dndDragImageElementRef?:ElementRef;\nprivate dragImage:Element;\nprivate isDragStarted:boolean = false;\n/**\n * @param {?} value\n * @return {?}\n */\nset dndDisableIf( value:boolean ) {\n\n    this.draggable = !value;\n\n    if( this.draggable ) {\n\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\n    }\n    else {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\n    }\n  }\n/**\n * @param {?} elementRef\n * @param {?} renderer\n */\nconstructor(\nprivate elementRef:ElementRef,\nprivate renderer:Renderer2 ) {\n  }\n/**\n * @return {?}\n */\nngOnDestroy():void {\n    if(this.isDragStarted === true) {\n      endDrag()\n    }\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nonDragStart( event:DndEvent ) {\n\n    if( this.draggable === false ) {\n\n      return false;\n    }\n\n    // check if there is dnd handle and if the dnd handle was used to start the drag\n    if( typeof this.dndHandle !== \"undefined\"\n      && typeof event._dndUsingHandle === \"undefined\" ) {\n\n      return false;\n    }\n\n    // initialize global state\n    startDrag( event, this.dndEffectAllowed, this.dndType );\n\n    this.isDragStarted = true;\n\n    setDragData( event, {data: this.dndDraggable, type: this.dndType}, dndState.effectAllowed );\n\n    this.determineDragImage();\n\n    // set dragging css class prior to setDragImage so styles are applied before\n    // TODO breaking change: add class to elementRef rather than drag image which could be another element\n    this.renderer.addClass( this.dragImage, this.dndDraggingClass );\n\n    // set custom dragimage if present\n    // set dragimage if drag is started from dndHandle\n    if( typeof this.dndDragImageElementRef !== \"undefined\"\n      || typeof event._dndUsingHandle !== \"undefined\" ) {\n\n      setDragImage( event, this.dragImage, this.dndDragImageOffsetFunction );\n    }\n\n    // add dragging source css class on first drag event\n    const /** @type {?} */ unregister = this.renderer.listen( this.elementRef.nativeElement, \"drag\", () => {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\n      unregister();\n    } );\n\n    this.dndStart.emit( event );\n\n    event.stopPropagation();\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nonDragEnd( event:DragEvent ) {\n\n    // get drop effect from custom stored state as its not reliable across browsers\n    const /** @type {?} */ dropEffect = dndState.dropEffect;\n\n    let /** @type {?} */ dropEffectEmitter:EventEmitter<DragEvent>;\n\n    switch( dropEffect ) {\n\n      case \"copy\":\n        dropEffectEmitter = this.dndCopied;\n        break;\n\n      case \"link\":\n        dropEffectEmitter = this.dndLinked;\n        break;\n\n      case \"move\":\n        dropEffectEmitter = this.dndMoved;\n        break;\n\n      default:\n        dropEffectEmitter = this.dndCanceled;\n        break;\n    }\n\n    dropEffectEmitter.emit( event );\n    this.dndEnd.emit( event );\n\n    // reset global state\n    endDrag();\n\n    this.isDragStarted = false;\n\n    this.renderer.removeClass( this.dragImage, this.dndDraggingClass );\n\n    // IE9 special hammering\n    window.setTimeout( () => {\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\n    }, 0 );\n\n    event.stopPropagation();\n  }\n/**\n * @param {?} handle\n * @return {?}\n */\nregisterDragHandle( handle:DndHandleDirective | undefined ) {\n\n    this.dndHandle = handle;\n  }\n/**\n * @param {?} elementRef\n * @return {?}\n */\nregisterDragImage( elementRef:ElementRef | undefined ) {\n\n    this.dndDragImageElementRef = elementRef;\n  }\n/**\n * @return {?}\n */\nprivate determineDragImage() {\n\n    // evaluate custom drag image existence\n    if( typeof this.dndDragImageElementRef !== \"undefined\" ) {\n\n      this.dragImage = /** @type {?} */(( this.dndDragImageElementRef.nativeElement as Element));\n    }\n    else {\n\n      this.dragImage = this.elementRef.nativeElement;\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: \"[dndDraggable]\"\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: Renderer2, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'dndDraggable': [{ type: Input },],\n'dndEffectAllowed': [{ type: Input },],\n'dndType': [{ type: Input },],\n'dndDraggingClass': [{ type: Input },],\n'dndDraggingSourceClass': [{ type: Input },],\n'dndDraggableDisabledClass': [{ type: Input },],\n'dndDragImageOffsetFunction': [{ type: Input },],\n'dndStart': [{ type: Output },],\n'dndEnd': [{ type: Output },],\n'dndMoved': [{ type: Output },],\n'dndCopied': [{ type: Output },],\n'dndLinked': [{ type: Output },],\n'dndCanceled': [{ type: Output },],\n'draggable': [{ type: HostBinding, args: [\"attr.draggable\", ] },],\n'dndDisableIf': [{ type: Input },],\n'onDragStart': [{ type: HostListener, args: [\"dragstart\", [ \"$event\" ], ] },],\n'onDragEnd': [{ type: HostListener, args: [\"dragend\", [ \"$event\" ], ] },],\n};\n}\n\nfunction DndDraggableDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nDndDraggableDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDndDraggableDirective.ctorParameters;\n/** @type {?} */\nDndDraggableDirective.propDecorators;\n/** @type {?} */\nDndDraggableDirective.prototype.dndDraggable;\n/** @type {?} */\nDndDraggableDirective.prototype.dndEffectAllowed;\n/** @type {?} */\nDndDraggableDirective.prototype.dndType;\n/** @type {?} */\nDndDraggableDirective.prototype.dndDraggingClass;\n/** @type {?} */\nDndDraggableDirective.prototype.dndDraggingSourceClass;\n/** @type {?} */\nDndDraggableDirective.prototype.dndDraggableDisabledClass;\n/** @type {?} */\nDndDraggableDirective.prototype.dndDragImageOffsetFunction;\n/** @type {?} */\nDndDraggableDirective.prototype.dndStart;\n/** @type {?} */\nDndDraggableDirective.prototype.dndEnd;\n/** @type {?} */\nDndDraggableDirective.prototype.dndMoved;\n/** @type {?} */\nDndDraggableDirective.prototype.dndCopied;\n/** @type {?} */\nDndDraggableDirective.prototype.dndLinked;\n/** @type {?} */\nDndDraggableDirective.prototype.dndCanceled;\n/** @type {?} */\nDndDraggableDirective.prototype.draggable;\n/** @type {?} */\nDndDraggableDirective.prototype.dndHandle;\n/** @type {?} */\nDndDraggableDirective.prototype.dndDragImageElementRef;\n/** @type {?} */\nDndDraggableDirective.prototype.dragImage;\n/** @type {?} */\nDndDraggableDirective.prototype.isDragStarted;\n/** @type {?} */\nDndDraggableDirective.prototype.elementRef;\n/** @type {?} */\nDndDraggableDirective.prototype.renderer;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {\n  AfterViewInit,\n  ContentChild,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostListener,\n  Input,\n  Output,\n  Renderer2\n} from '@angular/core';\nimport {\n  DndEvent,\n  DragDropData,\n  getDirectChildElement,\n  getDropData,\n  shouldPositionPlaceholderBeforeElement\n} from './dnd-utils';\nimport { getDndType, getDropEffect, isExternalDrag, setDropEffect } from './dnd-state';\nimport { DropEffect, EffectAllowed } from './dnd-types';\n\nexport interface DndDropEvent {\n  event:DragEvent;\n  dropEffect:DropEffect;\n  isExternal:boolean;\n  data?:any;\n  index?:number;\n  type?:any;\n}\nexport class DndPlaceholderRefDirective {\n/**\n * @param {?} elementRef\n */\nconstructor(\npublic readonly elementRef:ElementRef ) {\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: \"[dndPlaceholderRef]\"\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n];\n}\n\nfunction DndPlaceholderRefDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nDndPlaceholderRefDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDndPlaceholderRefDirective.ctorParameters;\n/** @type {?} */\nDndPlaceholderRefDirective.prototype.elementRef;\n}\n\nexport class DndDropzoneDirective implements AfterViewInit {\n\n  \n  dndDropzone?:string[];\n\n  \n  dndEffectAllowed:EffectAllowed;\n\n  \n  dndAllowExternal:boolean = false;\n\n  \n  dndHorizontal:boolean = false;\n\n  \n  dndDragoverClass:string = \"dndDragover\";\n\n  \n  dndDropzoneDisabledClass = \"dndDropzoneDisabled\";\n\n  \n  readonly dndDragover:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\n\n  \n  readonly dndDrop:EventEmitter<DndDropEvent> = new EventEmitter<DndDropEvent>();\nprivate readonly dndPlaceholderRef?:DndPlaceholderRefDirective;\nprivate placeholder:Element | null = null;\nprivate disabled:boolean = false;\n/**\n * @param {?} value\n * @return {?}\n */\nset dndDisableIf( value:boolean ) {\n\n    this.disabled = !!value;\n\n    if( this.disabled ) {\n\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\n    }\n    else {\n\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\n    }\n  }\n/**\n * @param {?} elementRef\n * @param {?} renderer\n */\nconstructor(\nprivate elementRef:ElementRef,\nprivate renderer:Renderer2 ) {\n  }\n/**\n * @return {?}\n */\nngAfterViewInit():void {\n\n    this.placeholder = this.tryGetPlaceholder();\n\n    if( this.placeholder !== null ) {\n\n      this.placeholder.remove();\n    }\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nonDragEnter( event:DndEvent ) {\n\n    // check if another dropzone is activated\n    if( event._dndDropzoneActive === true ) {\n\n      this.cleanupDragoverState();\n      return;\n    }\n\n    // set as active if the target element is inside this dropzone\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\n\n      const /** @type {?} */ newTarget = document.elementFromPoint( event.clientX, event.clientY );\n\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\n\n        event._dndDropzoneActive = true;\n      }\n    }\n\n    // check if this drag event is allowed to drop on this dropzone\n    const /** @type {?} */ type = getDndType( event );\n    if( this.isDropAllowed( type ) === false ) {\n\n      return;\n    }\n\n    // allow the dragenter\n    event.preventDefault();\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nonDragOver( event:DragEvent ) {\n\n    // check if this drag event is allowed to drop on this dropzone\n    const /** @type {?} */ type = getDndType( event );\n    if( this.isDropAllowed( type ) === false ) {\n\n      return;\n    }\n\n    this.checkAndUpdatePlaceholderPosition( event );\n\n    const /** @type {?} */ dropEffect = getDropEffect( event, this.dndEffectAllowed );\n\n    if( dropEffect === \"none\" ) {\n\n      this.cleanupDragoverState();\n      return;\n    }\n\n    // allow the dragover\n    event.preventDefault();\n\n    // set the drop effect\n    setDropEffect( event, dropEffect );\n\n    this.dndDragover.emit( event );\n\n    this.renderer.addClass( this.elementRef.nativeElement, this.dndDragoverClass );\n\n    event.stopPropagation();\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nonDrop( event:DragEvent ) {\n\n    try {\n\n      // check if this drag event is allowed to drop on this dropzone\n      const /** @type {?} */ type = getDndType( event );\n      if( this.isDropAllowed( type ) === false ) {\n\n        return;\n      }\n\n      const /** @type {?} */ data:DragDropData = getDropData( event, isExternalDrag() );\n\n      if( this.isDropAllowed( data.type ) === false ) {\n\n        return;\n      }\n\n      // signal custom drop handling\n      event.preventDefault();\n\n      const /** @type {?} */ dropEffect = getDropEffect( event );\n\n      setDropEffect( event, dropEffect );\n\n      if( dropEffect === \"none\" ) {\n\n        return;\n      }\n\n      const /** @type {?} */ dropIndex = this.getPlaceholderIndex();\n      this.dndDrop.emit( {\n        event: event,\n        dropEffect: dropEffect,\n        isExternal: isExternalDrag(),\n        data: data.data,\n        index: dropIndex,\n        type: type,\n      } );\n\n      event.stopPropagation();\n\n    }\n    finally {\n\n      this.cleanupDragoverState();\n    }\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nonDragLeave( event:DndEvent ) {\n\n    // check if still inside this dropzone and not yet handled by another dropzone\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\n\n      const /** @type {?} */ newTarget = document.elementFromPoint( event.clientX, event.clientY );\n\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\n\n        event._dndDropzoneActive = true;\n        return;\n      }\n    }\n\n    this.cleanupDragoverState();\n\n    // cleanup drop effect when leaving dropzone\n    setDropEffect( event, \"none\" );\n  }\n/**\n * @return {?}\n */\nprivate tryGetPlaceholder():Element | null {\n\n    if( typeof this.dndPlaceholderRef !== \"undefined\" ) {\n\n      return /** @type {?} */(( this.dndPlaceholderRef.elementRef.nativeElement as Element));\n    }\n\n    // TODO nasty workaround needed because if ng-container / template is used @ContentChild() or DI will fail because\n    // of wrong context see angular bug https://github.com/angular/angular/issues/13517\n    return this.elementRef.nativeElement.querySelector( \"[dndPlaceholderRef]\" );\n  }\n/**\n * @param {?=} type\n * @return {?}\n */\nprivate isDropAllowed( type?:string ):boolean {\n\n    // dropzone is disabled -> deny it\n    if( this.disabled === true ) {\n\n      return false;\n    }\n\n    // if drag did not start from our directive\n    // and external drag sources are not allowed -> deny it\n    if( isExternalDrag() === true\n      && this.dndAllowExternal === false ) {\n\n      return false;\n    }\n\n    // no filtering by types -> allow it\n    if( !this.dndDropzone ) {\n\n      return true;\n    }\n\n    // no type set -> allow it\n    if( !type ) {\n\n      return true;\n    }\n\n    if( Array.isArray( this.dndDropzone ) === false ) {\n\n      throw new Error( \"dndDropzone: bound value to [dndDropzone] must be an array!\" );\n    }\n\n    // if dropzone contains type -> allow it\n    return this.dndDropzone.indexOf( type ) !== -1;\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nprivate checkAndUpdatePlaceholderPosition( event:DragEvent ):void {\n\n    if( this.placeholder === null ) {\n\n      return;\n    }\n\n    // make sure the placeholder is in the DOM\n    if( this.placeholder.parentNode !== this.elementRef.nativeElement ) {\n\n      this.renderer.appendChild( this.elementRef.nativeElement, this.placeholder );\n    }\n\n    // update the position if the event originates from a child element of the dropzone\n    const /** @type {?} */ directChild = getDirectChildElement( this.elementRef.nativeElement, /** @type {?} */(( event.target as Element)) );\n\n    // early exit if no direct child or direct child is placeholder\n    if( directChild === null\n      || directChild === this.placeholder ) {\n\n      return;\n    }\n\n    const /** @type {?} */ positionPlaceholderBeforeDirectChild = shouldPositionPlaceholderBeforeElement( event, directChild, this.dndHorizontal );\n\n    if( positionPlaceholderBeforeDirectChild ) {\n\n      // do insert before only if necessary\n      if( directChild.previousSibling !== this.placeholder ) {\n\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild );\n      }\n    }\n    else {\n\n      // do insert after only if necessary\n      if( directChild.nextSibling !== this.placeholder ) {\n\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild.nextSibling );\n      }\n    }\n  }\n/**\n * @return {?}\n */\nprivate getPlaceholderIndex():number | undefined {\n\n    if( this.placeholder === null ) {\n\n      return undefined;\n    }\n\n    const /** @type {?} */ element = /** @type {?} */(( this.elementRef.nativeElement as HTMLElement));\n\n    return Array.prototype.indexOf.call( element.children, this.placeholder );\n  }\n/**\n * @return {?}\n */\nprivate cleanupDragoverState() {\n\n    this.renderer.removeClass( this.elementRef.nativeElement, this.dndDragoverClass );\n\n    if( this.placeholder !== null ) {\n\n      this.placeholder.remove();\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: \"[dndDropzone]\"\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: Renderer2, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'dndDropzone': [{ type: Input },],\n'dndEffectAllowed': [{ type: Input },],\n'dndAllowExternal': [{ type: Input },],\n'dndHorizontal': [{ type: Input },],\n'dndDragoverClass': [{ type: Input },],\n'dndDropzoneDisabledClass': [{ type: Input },],\n'dndDragover': [{ type: Output },],\n'dndDrop': [{ type: Output },],\n'dndPlaceholderRef': [{ type: ContentChild, args: [DndPlaceholderRefDirective, ] },],\n'dndDisableIf': [{ type: Input },],\n'onDragEnter': [{ type: HostListener, args: [\"dragenter\", [ \"$event\" ], ] },],\n'onDragOver': [{ type: HostListener, args: [\"dragover\", [ \"$event\" ], ] },],\n'onDrop': [{ type: HostListener, args: [\"drop\", [ \"$event\" ], ] },],\n'onDragLeave': [{ type: HostListener, args: [\"dragleave\", [ \"$event\" ], ] },],\n};\n}\n\nfunction DndDropzoneDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nDndDropzoneDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDndDropzoneDirective.ctorParameters;\n/** @type {?} */\nDndDropzoneDirective.propDecorators;\n/** @type {?} */\nDndDropzoneDirective.prototype.dndDropzone;\n/** @type {?} */\nDndDropzoneDirective.prototype.dndEffectAllowed;\n/** @type {?} */\nDndDropzoneDirective.prototype.dndAllowExternal;\n/** @type {?} */\nDndDropzoneDirective.prototype.dndHorizontal;\n/** @type {?} */\nDndDropzoneDirective.prototype.dndDragoverClass;\n/** @type {?} */\nDndDropzoneDirective.prototype.dndDropzoneDisabledClass;\n/** @type {?} */\nDndDropzoneDirective.prototype.dndDragover;\n/** @type {?} */\nDndDropzoneDirective.prototype.dndDrop;\n/** @type {?} */\nDndDropzoneDirective.prototype.dndPlaceholderRef;\n/** @type {?} */\nDndDropzoneDirective.prototype.placeholder;\n/** @type {?} */\nDndDropzoneDirective.prototype.disabled;\n/** @type {?} */\nDndDropzoneDirective.prototype.elementRef;\n/** @type {?} */\nDndDropzoneDirective.prototype.renderer;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Directive, HostBinding, HostListener } from '@angular/core';\nimport { DndEvent } from './dnd-utils';\nimport { DndDraggableDirective } from './dnd-draggable.directive';\nexport class DndHandleDirective {\n\n  \n  draggable = true;\n/**\n * @param {?} parent\n */\nconstructor( parent:DndDraggableDirective ) {\n\n    parent.registerDragHandle( this );\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nonDragEvent( event:DndEvent ) {\n\n    event._dndUsingHandle = true;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: \"[dndHandle]\"\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: DndDraggableDirective, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'draggable': [{ type: HostBinding, args: [\"attr.draggable\", ] },],\n'onDragEvent': [{ type: HostListener, args: [\"dragstart\", [ \"$event\" ], ] },{ type: HostListener, args: [\"dragend\", [ \"$event\" ], ] },],\n};\n}\n\nfunction DndHandleDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nDndHandleDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDndHandleDirective.ctorParameters;\n/** @type {?} */\nDndHandleDirective.propDecorators;\n/** @type {?} */\nDndHandleDirective.prototype.draggable;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { DndDraggableDirective, DndDragImageRefDirective } from './dnd-draggable.directive';\nimport { DndDropzoneDirective, DndPlaceholderRefDirective } from './dnd-dropzone.directive';\nimport { DndHandleDirective } from './dnd-handle.directive';\nexport class DndModule {\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  imports: [\n    CommonModule\n  ],\n  declarations: [\n    DndDraggableDirective,\n    DndDropzoneDirective,\n    DndHandleDirective,\n    DndPlaceholderRefDirective,\n    DndDragImageRefDirective\n  ],\n  exports: [\n    DndDraggableDirective,\n    DndDropzoneDirective,\n    DndHandleDirective,\n    DndPlaceholderRefDirective,\n    DndDragImageRefDirective\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction DndModule_tsickle_Closure_declarations() {\n/** @type {?} */\nDndModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDndModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["mimeTypeIsCustom","mimeType","substr","CUSTOM_MIME_TYPE","length","getWellKnownMimeType","event","types","dataTransfer","MSIE_MIME_TYPE","i","JSON_MIME_TYPE","setDragData","data","effectAllowed","type","dataString","JSON","stringify","setData","e","effectsAllowed","filterEffects","DROP_EFFECTS","getDropData","dragIsExternal","parse","getData","effects","allowed","filter","effect","toLowerCase","indexOf","getDirectChildElement","parentElement","childElement","directChild","parentNode","shouldPositionPlaceholderBeforeElement","element","horizontal","bounds","getBoundingClientRect","clientX","left","width","clientY","top","height","calculateDragImageOffset","dragImage","dragImageComputedStyle","window","getComputedStyle","paddingTop","parseFloat","paddingLeft","borderTop","borderTopWidth","borderLeft","borderLeftWidth","x","offsetX","y","offsetY","setDragImage","offsetFunction","offset","startDrag","_dndState","isDragging","dropEffect","endDrag","undefined","setDropEffect","getDropEffect","ctrlKey","altKey","getDndType","isExternalDrag","dndState","DndDragImageRefDirective","parent","elementRef","registerDragImage","decorators","Directive","args","selector","ctorParameters","DndDraggableDirective","ElementRef","renderer","this","dndEffectAllowed","dndDraggingClass","dndDraggingSourceClass","dndDraggableDisabledClass","dndDragImageOffsetFunction","dndStart","EventEmitter","dndEnd","dndMoved","dndCopied","dndLinked","dndCanceled","draggable","isDragStarted","Object","defineProperty","prototype","set","value","removeClass","nativeElement","addClass","ngOnDestroy","onDragStart","_this","dndHandle","_dndUsingHandle","dndType","dndDraggable","determineDragImage","dndDragImageElementRef","unregister","listen","emit","stopPropagation","onDragEnd","dropEffectEmitter","setTimeout","registerDragHandle","handle","Renderer2","propDecorators","Input","Output","HostBinding","dndDisableIf","HostListener","DndPlaceholderRefDirective","DndDropzoneDirective","dndAllowExternal","dndHorizontal","dndDragoverClass","dndDropzoneDisabledClass","dndDragover","dndDrop","placeholder","disabled","ngAfterViewInit","tryGetPlaceholder","remove","onDragEnter","_dndDropzoneActive","newTarget","document","elementFromPoint","contains","isDropAllowed","preventDefault","cleanupDragoverState","onDragOver","checkAndUpdatePlaceholderPosition","onDrop","dropIndex","getPlaceholderIndex","isExternal","index","onDragLeave","dndPlaceholderRef","querySelector","dndDropzone","Array","isArray","Error","appendChild","previousSibling","insertBefore","nextSibling","call","children","ContentChild","DndHandleDirective","onDragEvent","DndModule","NgModule","imports","CommonModule","declarations","exports"],"mappings":"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"}
